<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Even&amp;Fzq</title>
  
  <subtitle>月色三分</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fzqeven.top/"/>
  <updated>2019-02-18T15:06:45.875Z</updated>
  <id>https://fzqeven.top/</id>
  
  <author>
    <name>Even</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CAS单点登录原理解析（转载）</title>
    <link href="https://fzqeven.top/2019/02/18/CAS%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
    <id>https://fzqeven.top/2019/02/18/CAS单点登录原理解析（转载）/</id>
    <published>2019-02-18T15:06:45.873Z</published>
    <updated>2019-02-18T15:06:45.875Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、基于Cookie的单点登录的回顾"><a href="#1、基于Cookie的单点登录的回顾" class="headerlink" title="1、基于Cookie的单点登录的回顾"></a>1、基于Cookie的单点登录的回顾</h2><p>​      <img src="http://img.blog.csdn.net/20161019093616343" alt="img"></p><p>基于Cookie的单点登录核心原理：</p><p>​      将用户名密码加密之后存于Cookie中，之后访问网站时在过滤器（filter）中校验用户权限，如果没有权限则从Cookie中取出用户名密码进行登录，让用户从某种意义上觉得只登录了一次。</p><p>​      该方式缺点就是多次传送用户名密码，增加被盗风险，以及不能跨域。同时<a href="http://www.qiandu.com与mail.qiandu.com同时拥有登录逻辑的代码，如果涉及到修改操作，则需要修改两处。" target="_blank" rel="noopener">www.qiandu.com与mail.qiandu.com同时拥有登录逻辑的代码，如果涉及到修改操作，则需要修改两处。</a></p><h2 id="2、统一认证中心方案原理"><a href="#2、统一认证中心方案原理" class="headerlink" title="2、统一认证中心方案原理"></a>2、统一认证中心方案原理</h2><p>​      在生活中我们也有类似的相关生活经验，例如你去食堂吃饭，食堂打饭的阿姨（<a href="http://www.qiandu.com）告诉你，不收现金。并且告诉你，你去门口找换票的（passport.com）换小票。于是你换完票之后，再去找食堂阿姨，食堂阿姨拿着你的票，问门口换票的，这个票是真的吗？换票的说，是真的，于是给你打饭了。" target="_blank" rel="noopener">www.qiandu.com）告诉你，不收现金。并且告诉你，你去门口找换票的（passport.com）换小票。于是你换完票之后，再去找食堂阿姨，食堂阿姨拿着你的票，问门口换票的，这个票是真的吗？换票的说，是真的，于是给你打饭了。</a></p><p>​      基于上述生活中的场景，我们将基于Cookie的单点登录改良以后的方案如下：</p><p>​      <img src="http://img.blog.csdn.net/20161019094253356" alt="img"></p><p>​      经过分析，Cookie单点登录认证太过于分散，每个网站都持有一份登陆认证代码。于是我们将认证统一化，形成一个独立的服务。当我们需要登录操作时，则重定向到统一认证中心<a href="http://passport.com。于是乎整个流程就如上图所示：" target="_blank" rel="noopener">http://passport.com。于是乎整个流程就如上图所示：</a><br>      第一步：用户访问<a href="http://www.qiandu.com。过滤器判断用户是否登录，没有登录，则重定向（302）到网站http://passport.com。" target="_blank" rel="noopener">www.qiandu.com。过滤器判断用户是否登录，没有登录，则重定向（302）到网站http://passport.com。</a><br>      第二步：重定向到passport.com，输入用户名密码。passport.com将用户登录的信息记录到服务器的session中。<br>      第三步：passport.com给浏览器发送一个特殊的凭证，浏览器将凭证交给<a href="http://www.qiandu.com，www.qiandu.com则拿着浏览器交给他的凭证去passport.com验证凭证是否有效，从而判断用户是否登录成功。" target="_blank" rel="noopener">www.qiandu.com，www.qiandu.com则拿着浏览器交给他的凭证去passport.com验证凭证是否有效，从而判断用户是否登录成功。</a><br>      第四步：登录成功，浏览器与网站之间进行正常的访问。</p><h2 id="3、Yelu大学研发的CAS-Central-Authentication-Server"><a href="#3、Yelu大学研发的CAS-Central-Authentication-Server" class="headerlink" title="3、Yelu大学研发的CAS(Central Authentication Server)"></a>3、Yelu大学研发的CAS(Central Authentication Server)</h2><p>下面就以耶鲁大学研发的CAS为分析依据，分析其工作原理。首先看一下最上层的项目部署图：</p><p>​      <img src="http://img.blog.csdn.net/20161019102316936" alt="img"></p><p>部署项目时需要部署一个独立的认证中心（cas.qiandu.com），以及其他N个用户自己的web服务。</p><p>认证中心：也就是cas.qiandu.com，即cas-server。用来提供认证服务，由CAS框架提供，用户只需要根据业务实现认证的逻辑即可。</p><p>用户web项目：只需要在web.xml中配置几个过滤器，用来保护资源，过滤器也是CAS框架提供了，即cas-client，基本不需要改动可以直接使用。</p><h2 id="4、CAS的详细登录流程"><a href="#4、CAS的详细登录流程" class="headerlink" title="4、CAS的详细登录流程"></a>4、CAS的详细登录流程</h2><p><img src="http://img.blog.csdn.net/20161019102701266" alt="img"></p><p>上图是3个登录场景，分别为：第一次访问<a href="http://www.qiandu.com、第二次访问、以及登录状态下第一次访问mail.qiandu.com。" target="_blank" rel="noopener">www.qiandu.com、第二次访问、以及登录状态下第一次访问mail.qiandu.com。</a></p><p>下面就详细说明上图中每个数字标号做了什么，以及相关的请求内容，响应内容。</p><h3 id="4-1、第一次访问www-qiandu-com"><a href="#4-1、第一次访问www-qiandu-com" class="headerlink" title="4.1、第一次访问www.qiandu.com"></a>4.1、第一次访问<a href="http://www.qiandu.com" target="_blank" rel="noopener">www.qiandu.com</a></h3><p>标号1：用户访问<a href="http://www.qiandu.com，经过他的第一个过滤器（cas提供，在web.xml中配置）AuthenticationFilter。" target="_blank" rel="noopener">http://www.qiandu.com，经过他的第一个过滤器（cas提供，在web.xml中配置）AuthenticationFilter。</a></p><p>​      过滤器全称：org.jasig.cas.client.authentication.AuthenticationFilter</p><p>​      主要作用：判断是否登录，如果没有登录则重定向到认证中心。</p><p>标号2：<a href="http://www.qiandu.com发现用户没有登录，则返回浏览器重定向地址。" target="_blank" rel="noopener">www.qiandu.com发现用户没有登录，则返回浏览器重定向地址。</a></p><p>​      <img src="http://img.blog.csdn.net/20161019112614493" alt="img"></p><p>​      首先可以看到我们请求<a href="http://www.qiandu.com，之后浏览器返回状态码302，然后让浏览器重定向到cas.qiandu.com并且通过get的方式添加参数service，该参数目的是登录成功之后会要重定向回来，因此需要该参数。并且你会发现，其实server的值就是编码之后的我们请求www.qiandu.com的地址。" target="_blank" rel="noopener">www.qiandu.com，之后浏览器返回状态码302，然后让浏览器重定向到cas.qiandu.com并且通过get的方式添加参数service，该参数目的是登录成功之后会要重定向回来，因此需要该参数。并且你会发现，其实server的值就是编码之后的我们请求www.qiandu.com的地址。</a></p><p>标号3：浏览器接收到重定向之后发起重定向，请求cas.qiandu.com。</p><p>标号4：认证中心cas.qiandu.com接收到登录请求，返回登陆页面。</p><p>​      <img src="http://img.blog.csdn.net/20161019135648079" alt="img"></p><p>​      上图就是标号3的请求，以及标号4的响应。请求的URL是标号2返回的URL。之后认证中心就展示登录的页面，等待用户输入用户名密码。</p><p>标号5：用户在cas.qiandu.com的login页面输入用户名密码，提交。</p><p>标号6：服务器接收到用户名密码，则验证是否有效，验证逻辑可以使用cas-server提供现成的，也可以自己实现。</p><p>​      <img src="http://img.blog.csdn.net/20161019135605507" alt="img"></p><p>​      上图就是标号5的请求，以及标号6的响应了。当cas.qiandu.com即csa-server认证通过之后，会返回给浏览器302，重定向的地址就是Referer中的service参数对应的值。后边并通过get的方式挟带了一个ticket令牌，这个ticket就是ST（数字3处）。同时会在Cookie中设置一个CASTGC，该cookie是网站cas.qiandu.com的cookie，只有访问这个网站才会携带这个cookie过去。</p><p>​      Cookie中的CASTGC：向cookie中添加该值的目的是当下次访问cas.qiandu.com时，浏览器将Cookie中的TGC携带到服务器，服务器根据这个TGC，查找与之对应的TGT。从而判断用户是否登录过了，是否需要展示登录页面。TGT与TGC的关系就像SESSION与Cookie中SESSIONID的关系。</p><p>​      TGT：Ticket Granted Ticket（俗称大令牌，或者说票根，他可以签发ST）</p><p>​      TGC：Ticket Granted Cookie（cookie中的value），存在Cookie中，根据他可以找到TGT。</p><p>​      ST：Service Ticket （小令牌），是TGT生成的，默认是用一次就生效了。也就是上面数字3处的ticket值。</p><p>标号7：浏览器从cas.qiandu.com哪里拿到ticket之后，就根据指示重定向到<a href="http://www.qiandu.com，请求的url就是上面返回的url。" target="_blank" rel="noopener">www.qiandu.com，请求的url就是上面返回的url。</a></p><p>​      <img src="http://img.blog.csdn.net/20161019141840991" alt="img"></p><p>标号8：<a href="http://www.qiandu.com在过滤器中会取到ticket的值，然后通过http方式调用cas.qiandu.com验证该ticket是否是有效的。" target="_blank" rel="noopener">www.qiandu.com在过滤器中会取到ticket的值，然后通过http方式调用cas.qiandu.com验证该ticket是否是有效的。</a></p><p>标号9：cas.qiandu.com接收到ticket之后，验证，验证通过返回结果告诉<a href="http://www.qiandu.com该ticket有效。" target="_blank" rel="noopener">www.qiandu.com该ticket有效。</a></p><p>标号10：<a href="http://www.qiandu.com接收到cas-server的返回，知道了用户合法，展示相关资源到用户浏览器上。" target="_blank" rel="noopener">www.qiandu.com接收到cas-server的返回，知道了用户合法，展示相关资源到用户浏览器上。</a></p><p>​      <img src="http://img.blog.csdn.net/20161019141914038" alt="img"></p><p>​      至此，第一次访问的整个流程结束，其中标号8与标号9的环节是通过代码调用的，并不是浏览器发起，所以没有截取到报文。</p><h2 id="4-2、第二次访问www-qiandu-com"><a href="#4-2、第二次访问www-qiandu-com" class="headerlink" title="4.2、第二次访问www.qiandu.com"></a>4.2、第二次访问<a href="http://www.qiandu.com" target="_blank" rel="noopener">www.qiandu.com</a></h2><p>上面以及访问过一次了，当第二次访问的时候发生了什么呢？</p><p>标号11：用户发起请求，访问<a href="http://www.qiandu.com。会经过cas-client，也就是过滤器，因为第一次访问成功之后www.qiandu.com中会在session中记录用户信息，因此这里直接就通过了，不用验证了。" target="_blank" rel="noopener">www.qiandu.com。会经过cas-client，也就是过滤器，因为第一次访问成功之后www.qiandu.com中会在session中记录用户信息，因此这里直接就通过了，不用验证了。</a></p><p>标号12：用户通过权限验证，浏览器返回正常资源。</p><h2 id="4-3、访问mail-qiandu-com"><a href="#4-3、访问mail-qiandu-com" class="headerlink" title="4.3、访问mail.qiandu.com"></a>4.3、访问mail.qiandu.com</h2><p>标号13：用户在<a href="http://www.qiandu.com正常上网，突然想访问mail.qiandu.com，于是发起访问mail.qiandu.com的请求。" target="_blank" rel="noopener">www.qiandu.com正常上网，突然想访问mail.qiandu.com，于是发起访问mail.qiandu.com的请求。</a></p><p>标号14：mail.qiandu.com接收到请求，发现第一次访问，于是给他一个重定向的地址，让他去找认证中心登录。</p><p>​      <img src="http://img.blog.csdn.net/20161019144151085" alt="img"></p><p>​      上图可以看到，用户请求mail.qiandu.com，然后返回给他一个网址，状态302重定向，service参数就是回来的地址。</p><p>标号15：浏览器根据14返回的地址，发起重定向，因为之前访问过一次了，因此这次会携带上次返回的Cookie：TGC到认证中心。</p><p>标号16：认证中心收到请求，发现TGC对应了一个TGT，于是用TGT签发一个ST，并且返回给浏览器，让他重定向到mail.qiandu.com</p><p>​      <img src="http://img.blog.csdn.net/20161019144534318" alt="img"></p><p>​      可以发现请求的时候是携带Cookie：CASTGC的，响应的就是一个地址加上TGT签发的ST也就是ticket。</p><p>标号17：浏览器根据16返回的网址发起重定向。</p><p>标号18：mail.qiandu.com获取ticket去认证中心验证是否有效。</p><p>标号19：认证成功，返回在mail.qiandu.com的session中设置登录状态，下次就直接登录。</p><p>标号20：认证成功之后就反正用想要访问的资源了。</p><p>​      <img src="http://img.blog.csdn.net/20161019144836578" alt="img"></p><h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>​      至此，CAS登录的整个过程就完毕了，以后有时间总结下如何使用CAS，并运用到项目中。</p><p>原文链接:</p><p><a href="https://www.cnblogs.com/lihuidu/p/6495247.html" target="_blank" rel="noopener">https://www.cnblogs.com/lihuidu/p/6495247.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、基于Cookie的单点登录的回顾&quot;&gt;&lt;a href=&quot;#1、基于Cookie的单点登录的回顾&quot; class=&quot;headerlink&quot; title=&quot;1、基于Cookie的单点登录的回顾&quot;&gt;&lt;/a&gt;1、基于Cookie的单点登录的回顾&lt;/h2&gt;&lt;p&gt;​     
      
    
    </summary>
    
      <category term="java" scheme="https://fzqeven.top/categories/java/"/>
    
    
      <category term="cas单点登录" scheme="https://fzqeven.top/tags/cas%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>四  | centerOS7安装jdk1.8 | 以及几个小bug</title>
    <link href="https://fzqeven.top/2019/02/18/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%884%EF%BC%89/"/>
    <id>https://fzqeven.top/2019/02/18/服务器（4）/</id>
    <published>2019-02-18T06:24:33.743Z</published>
    <updated>2019-02-18T06:24:33.744Z</updated>
    
    <content type="html"><![CDATA[<p>1、将下载好的jdk包通过xshell上传到centos操作系统 </p><p>// 这里我是直接解压了放在了/home/docker/mysoftware/</p><p>2、进行解压</p><p>tar -vxzf jdk-8u45-linux-x64.tar.gz</p><p>3、编辑系统环境变量</p><p>vim /etc/profile<br>并在文件最后添加：</p><p>export JAVA_HOME=/root/jdk1.8.0_45   //这里根据自己的jdk包所在的位置进行自行更改<br>export PATH=$JAVA_HOME/bin:$PATH<br><img src="https://img-blog.csdnimg.cn/20190115160453185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjMwMjcw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>4、执行命令 . /etc/profile<br>// 这里 . 与 / 之间存在一个空格<br>// 若在当前目录在/etc/，那么可以直接执行./profile，这里 . 与 /没有空格<br>5、输入java -version 进行测试 </p><p><img src="https://img-blog.csdnimg.cn/201901151657528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjMwMjcw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>配置成功！</p><h3 id="配置jdk时bug"><a href="#配置jdk时bug" class="headerlink" title="配置jdk时bug"></a>配置jdk时bug</h3><h4 id="bash-home-docker-mysoft-jdk1-8-0-191-bin-java-Permission-denied"><a href="#bash-home-docker-mysoft-jdk1-8-0-191-bin-java-Permission-denied" class="headerlink" title="-bash: /home/docker/mysoft/jdk1.8.0_191/bin/java: Permission denied"></a>-bash: /home/docker/mysoft/jdk1.8.0_191/bin/java: Permission denied</h4><p>这个问题是文件夹没给权限：<br>输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 /home/docker/mysoft/jdk1.8.0_191/ （这些是自己的文件夹路径）</span><br></pre></td></tr></table></figure></p><h4 id="java-error-while-loading-shared-libraries-libjli-so-cannot-open-shared-object-file"><a href="#java-error-while-loading-shared-libraries-libjli-so-cannot-open-shared-object-file" class="headerlink" title="java error while loading shared libraries: libjli.so: cannot open shared object file"></a>java error while loading shared libraries: libjli.so: cannot open shared object file</h4><p>输入find / -name libjli.so<br>将libjli.so的绝对路径添加到/etc/ld.so.conf中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/docker/mysoft/jdk1.8.0_191/jre/lib/amd64/jli/</span><br></pre></td></tr></table></figure></p><p>执行ldconfig</p><p>再java -version<br>OK!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、将下载好的jdk包通过xshell上传到centos操作系统 &lt;/p&gt;
&lt;p&gt;// 这里我是直接解压了放在了/home/docker/mysoftware/&lt;/p&gt;
&lt;p&gt;2、进行解压&lt;/p&gt;
&lt;p&gt;tar -vxzf jdk-8u45-linux-x64.tar.gz
      
    
    </summary>
    
      <category term="阿里云服务器" scheme="https://fzqeven.top/categories/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Linux" scheme="https://fzqeven.top/tags/Linux/"/>
    
      <category term="docker" scheme="https://fzqeven.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>java中线程不安全怎么理解</title>
    <link href="https://fzqeven.top/2019/02/18/java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3/"/>
    <id>https://fzqeven.top/2019/02/18/java中线程不安全怎么理解/</id>
    <published>2019-02-18T06:21:26.346Z</published>
    <updated>2019-02-18T06:21:26.347Z</updated>
    
    <content type="html"><![CDATA[<p>当我们查看JDK API的时候，总会发现一些类说明写着，线程安全或者线程不安全，比如说到StringBuilder中，有这么一句，“将StringBuilder 的实例用于多个线程是不安全的。如果需要这样的同步，则建议使用StringBuffer。”，提到StringBuffer时，说到“StringBuffer是线程安全的可变字符序列，一个类似于String的字符串缓冲区，虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致”。StringBuilder是一个可变的字符序列，此类提供一个与StringBuffe兼容的API，但不保证同步。该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快。将StringBuilder的实例用于多个线程是不安全的，如果需要这样的同步，则建议使用StringBuffer。</p><p>　　 根据以上JDK文档中对StringBuffer和StringBuilder的描述，得到对String、StringBuilder与StringBuffer三者使用情况的总结：<br>　　 1、如果要操作少量的数据用String<br>　　 2、单线程操作字符串缓冲区下操作大量数据StringBuilder<br>　　 3、多线程操作字符串缓冲区下操作大量数据StringBuffer</p><p>　　 那么下面手动创建一个线程不安全的类，然后在多线程中使用这个类，看看有什么效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Count &#123;  </span><br><span class="line">    private int num;  </span><br><span class="line">    public void count() &#123;  </span><br><span class="line">        for(int i = 1; i &lt;= 10; i++) &#123;  </span><br><span class="line">            num += i;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;-&quot; + num);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　 在这个类中的count方法计算1一直加到10的和，并输出当前线程名和总和，我们期望的是每个线程都会输出55。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Runnable runnable = new Runnable() &#123;  </span><br><span class="line">            Count count = new Count();  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                count.count();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; 10; i++) &#123;  </span><br><span class="line">            new Thread(runnable).start();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　 这里启动了10个线程，看一下输出结果：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Thread-0-55  </span><br><span class="line">Thread-1-110  </span><br><span class="line">Thread-2-165  </span><br><span class="line">Thread-4-220  </span><br><span class="line">Thread-5-275  </span><br><span class="line">Thread-6-330  </span><br><span class="line">Thread-3-385  </span><br><span class="line">Thread-7-440  </span><br><span class="line">Thread-8-495  </span><br><span class="line">Thread-9-550</span><br></pre></td></tr></table></figure></p><p>　　 只有Thread-0线程输出的结果是我们期望的，而输出的是每次都累加的，要想得到我们期望的结果，有几种解决方案：</p><p>　　 1、将Count类中的成员变量num变成count方法的局部变量；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Count &#123;  </span><br><span class="line">    public void count() &#123;  </span><br><span class="line">        int num = 0;  </span><br><span class="line">        for(int i = 1; i &lt;= 10; i++) &#123;  </span><br><span class="line">            num += i;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + ”-“ + num);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　 2、将线程类成员变量拿到run方法中，这时count引用是线程内的局部变量；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest4 &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Runnable runnable = new Runnable() &#123;  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                Count count = new Count();  </span><br><span class="line">                count.count();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">        for(int i = 0; i &lt; 10; i++) &#123;  </span><br><span class="line">            new Thread(runnable).start();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　 3、每次启动一个线程使用不同的线程类，不推荐。</p><p>　　 通过上述测试，我们发现，存在成员变量的类用于多线程时是不安全的，不安全体现在这个成员变量可能发生非原子性的操作，而变量定义在方法内也就是局部变量是线程安全的。想想在使用struts1时，不推荐创建成员变量，因为action是单例的，如果创建了成员变量，就会存在线程不安全的隐患，而struts2是每一次请求都会创建一个action，就不用考虑线程安全的问题。所以，日常开发中，通常需要考虑成员变量或者说全局变量在多线程环境下，是否会引发一些问题。</p><p>　　 要说明线程同步问题首先要说明Java线程的两个特性，可见性和有序性。</p><p>　　 多个线程之间是不能直接传递数据进行交互的，它们之间的交互只能通过共享变量来实现。拿上面的例子来说明，在多个线程之间共享了Count类的一个实例，这个对象是被创建在主内存（堆内存）中，每个线程都有自己的工作内存（线程栈），工作内存存储了主内存count对象的一个副本，当线程操作count对象时，首先从主内存复制count对象到工作内存中，然后执行代码count.count()，改变了num值，最后用工作内存中的count刷新主内存的 count。当一个对象在多个工作内存中都存在副本时，如果一个工作内存刷新了主内存中的共享变量，其它线程也应该能够看到被修改后的值，此为可见性。</p><h2 id="多个线程执行时，CPU对线程的调度是随机的，我们不知道当前程序被执行到哪步就切换到了下一个线程，一个最经典的例子就是银行汇款问题，一个银行账户存款100，这时一个人从该账户取10元，同时另一个人向该账户汇10元，那么余额应该还是100。那么此时可能发生这种情况，A线程负责取款，B线程负责汇款，A从主内存读到100，B从主内存读到100，A执行减10操作，并将数据刷新到主内存，这时主内存数据100-10-90，而B内存执行加10操作，并将数据刷新到主内存，最后主内存数据100-10-110，显然这是一个严重的问题，我们要保证A线程和B线程有序执行，先取款后汇款或者先汇款后取款，此为有序性。"><a href="#多个线程执行时，CPU对线程的调度是随机的，我们不知道当前程序被执行到哪步就切换到了下一个线程，一个最经典的例子就是银行汇款问题，一个银行账户存款100，这时一个人从该账户取10元，同时另一个人向该账户汇10元，那么余额应该还是100。那么此时可能发生这种情况，A线程负责取款，B线程负责汇款，A从主内存读到100，B从主内存读到100，A执行减10操作，并将数据刷新到主内存，这时主内存数据100-10-90，而B内存执行加10操作，并将数据刷新到主内存，最后主内存数据100-10-110，显然这是一个严重的问题，我们要保证A线程和B线程有序执行，先取款后汇款或者先汇款后取款，此为有序性。" class="headerlink" title="　　 多个线程执行时，CPU对线程的调度是随机的，我们不知道当前程序被执行到哪步就切换到了下一个线程，一个最经典的例子就是银行汇款问题，一个银行账户存款100，这时一个人从该账户取10元，同时另一个人向该账户汇10元，那么余额应该还是100。那么此时可能发生这种情况，A线程负责取款，B线程负责汇款，A从主内存读到100，B从主内存读到100，A执行减10操作，并将数据刷新到主内存，这时主内存数据100-10=90，而B内存执行加10操作，并将数据刷新到主内存，最后主内存数据100+10=110，显然这是一个严重的问题，我们要保证A线程和B线程有序执行，先取款后汇款或者先汇款后取款，此为有序性。"></a>　　 多个线程执行时，CPU对线程的调度是随机的，我们不知道当前程序被执行到哪步就切换到了下一个线程，一个最经典的例子就是银行汇款问题，一个银行账户存款100，这时一个人从该账户取10元，同时另一个人向该账户汇10元，那么余额应该还是100。那么此时可能发生这种情况，A线程负责取款，B线程负责汇款，A从主内存读到100，B从主内存读到100，A执行减10操作，并将数据刷新到主内存，这时主内存数据100-10=90，而B内存执行加10操作，并将数据刷新到主内存，最后主内存数据100+10=110，显然这是一个严重的问题，我们要保证A线程和B线程有序执行，先取款后汇款或者先汇款后取款，此为有序性。</h2><p>原文：<a href="https://blog.csdn.net/fuzhongmin05/article/details/59110866" target="_blank" rel="noopener">https://blog.csdn.net/fuzhongmin05/article/details/59110866</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们查看JDK API的时候，总会发现一些类说明写着，线程安全或者线程不安全，比如说到StringBuilder中，有这么一句，“将StringBuilder 的实例用于多个线程是不安全的。如果需要这样的同步，则建议使用StringBuffer。”，提到StringBuf
      
    
    </summary>
    
      <category term="Java" scheme="https://fzqeven.top/categories/Java/"/>
    
    
      <category term="线程不安全" scheme="https://fzqeven.top/tags/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot| 怎么找到我们需要的场景启动器的配置?</title>
    <link href="https://fzqeven.top/2019/02/18/SpringBoot-%E6%80%8E%E4%B9%88%E6%89%BE%E5%88%B0%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E7%9A%84%E5%9C%BA%E6%99%AF%E5%90%AF%E5%8A%A8%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>https://fzqeven.top/2019/02/18/SpringBoot-怎么找到我们需要的场景启动器的配置/</id>
    <published>2019-02-18T06:18:59.129Z</published>
    <updated>2019-02-18T06:18:59.129Z</updated>
    
    <content type="html"><![CDATA[<p>官方文档:<br><a href="https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/reference/html/using-boot-build-systems.html#using-boot-starter" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/reference/html/using-boot-build-systems.html#using-boot-starter</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;官方文档:&lt;br&gt;&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/reference/html/using-boot-build-systems.html#using-boot-starter&quot; 
      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://fzqeven.top/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://fzqeven.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Servlet-mapping|容器的Context对象对请求路径(URL)怎么处理</title>
    <link href="https://fzqeven.top/2019/02/18/Servlet-mapping%E5%AE%B9%E5%99%A8%E7%9A%84Context%E5%AF%B9%E8%B1%A1%E5%AF%B9%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84(URL)%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/"/>
    <id>https://fzqeven.top/2019/02/18/Servlet-mapping容器的Context对象对请求路径(URL)怎么处理/</id>
    <published>2019-02-18T06:17:22.808Z</published>
    <updated>2019-02-18T06:17:22.809Z</updated>
    
    <content type="html"><![CDATA[<p>容器的Context对象对请求路径(URL)做出处理，去掉请求URL的上下文路径后，按路径映射规则和Servlet映射路径（<url- pattern="">）做匹配，如果匹配成功，则调用这个Servlet处理请求。 servlet容器对url的匹配过程：</url-></p><p>当一个请求发送到servlet容器的时候，容器先会将请求的url减去当前应用上下文的路径作为servlet的映射url，比如我访问的是<a href="http://localhost/test/aaa.html，我的应用上下文是test，容器会将http://localhost/test去掉，剩下的/aaa.html部分拿来做servlet的映射匹配。这个映射匹配过程是有顺序的，而且当有一个servlet匹配成功以后，就不会去理会剩下的servlet了（filter不同，后文会提到）。其匹配规则和顺序如下：" target="_blank" rel="noopener">http://localhost/test/aaa.html，我的应用上下文是test，容器会将http://localhost/test去掉，剩下的/aaa.html部分拿来做servlet的映射匹配。这个映射匹配过程是有顺序的，而且当有一个servlet匹配成功以后，就不会去理会剩下的servlet了（filter不同，后文会提到）。其匹配规则和顺序如下：</a></p><ol><li><p>精确路径匹配。例子：比如servletA 的url-pattern为 /test，servletB的url-pattern为 /* ，这个时候，如果我访问的url为<a href="http://localhost/test" target="_blank" rel="noopener">http://localhost/test</a> ，这个时候容器就会先进行精确路径匹配，发现/test正好被servletA精确匹配，那么就去调用servletA，也不会去理会其他的servlet了。</p></li><li><p>最长路径匹配。例子：servletA的url-pattern为/test/，而servletB的url-pattern为/test/a/，此时访问<a href="http://localhost/test/a时，容器会选择路径最长的servlet来匹配，也就是这里的servletB。" target="_blank" rel="noopener">http://localhost/test/a时，容器会选择路径最长的servlet来匹配，也就是这里的servletB。</a></p></li><li><p>扩展匹配，如果url最后一段包含扩展，容器将会根据扩展选择合适的servlet。例子：servletA的url-pattern：*.action</p></li></ol><p>如果前面三条规则都没有找到一个servlet，容器会根据url选择对应的请求资源。如果应用定义了一个default servlet，则容器会将请求丢给default servlet）。</p><p>根据这个规则表，就能很清楚的知道servlet的匹配过程，所以定义servlet的时候也要考虑url-pattern的写法，以免出错。</p><p>对于filter，不会像servlet那样只匹配一个servlet，因为filter的集合是一个链，所以只会有处理的顺序不同，而不会出现只选择一个filter。Filter的处理顺序和filter-mapping在web.xml中定义的顺序相同。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;容器的Context对象对请求路径(URL)做出处理，去掉请求URL的上下文路径后，按路径映射规则和Servlet映射路径（&lt;url- pattern=&quot;&quot;&gt;）做匹配，如果匹配成功，则调用这个Servlet处理请求。 servlet容器对url的匹配过程：&lt;/url-&gt;&lt;/
      
    
    </summary>
    
      <category term="Java" scheme="https://fzqeven.top/categories/Java/"/>
    
    
      <category term="URL" scheme="https://fzqeven.top/tags/URL/"/>
    
  </entry>
  
  <entry>
    <title>java中的上下文,servletContext以及idea中提示配置默认spring上下文</title>
    <link href="https://fzqeven.top/2019/02/18/java%E4%B8%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87,servletContext%E4%BB%A5%E5%8F%8Aidea%E4%B8%AD%E6%8F%90%E7%A4%BA%E9%85%8D%E7%BD%AE%E9%BB%98%E8%AE%A4spring%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://fzqeven.top/2019/02/18/java中的上下文,servletContext以及idea中提示配置默认spring上下文/</id>
    <published>2019-02-18T06:14:49.183Z</published>
    <updated>2019-02-18T06:14:49.184Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单理解"><a href="#简单理解" class="headerlink" title="简单理解"></a>简单理解</h2><ol><li>context<br>在当前环境下你能拿到的参数都可以从context出发去拿,而不仅仅是放URL的.从里面可以拿到request,<br>session,response…….,可以说只要你拿到了context就可以访问任何你有权限访问的东西</li><li>context就是“容器”，放的就是应用程序的所有资源，要用时候就访问它，所以context里面的东西，在同一个应用程序里面是全局的。</li><li>是一个包含各种context的设置的对象<br>例如：pageContext就包含了该页面的各种设置。可以通过他得到该页面所在服务器路径等等。<br>Context 用于在 Request 操作中指定上下文对象的对象，上下文字符串在与请求调用一起被发送之前，必须在该指定的上下文对象中进行解析。Context 对象包含 NamedValue 对象形式的属性列表。这些属性表示关于客户端、环境或请求情形的信息，它们通常是一些可能不方便作为参数传递的属性。</li></ol><p>所谓上下文，它是用来存储系统的一些初始化信息，例如在jboss中通过配置文件指定了数据源，那么在jboss启动的时候就把这个文件的相关信息上下文中，于是在我们使用这个数据源的时候，就需要先获得系统的上下文，然后再通过一定的方式将数据源取出来。至于在系统启动时，是如何将这些初始化信息加载到上下文中，而上下文在程序中具体又是以什么形式体现的，应该随着系统的不同而不同。</p><p>　　上下文即ServletContext,(在java　web中,代表整个web应用,可以和整个应用的容器,即服务器,进行交互)是一个全局的储存信息的空间，服务器启动，其就存在，服务器关闭，其才释放。所有用户共用一个ServletContext。所以，为了节省空间，提高效率，ServletContext中，要放必须的、重要的、所有用户需要共享的线程又是安全的一些信息。如，做一个购物类的网站，要从数据库中提取物品信息，如果用session保存这些物品信息，每个用户都访问一便数据库，效率就太低了；所以要用来Servlet上下文来保存，在服务器开始时，就访问数据库，将物品信息存入Servlet上下文中，这样，每个用户只用从上下文中读入物品信息就行了。</p><p>　　获取ServletContext的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br><span class="line">　 session.getServletContext();</span><br></pre></td></tr></table></figure></p><p>在百科上还有一种说法是:文件所在的路径<br>顺便整体整理和理解了一波ServletContext</p><h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><blockquote><p>引用自百度百科,xmind文档[笔记15]</p></blockquote><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>每个应用都会有一个ServletContext对象与之关联,当容器分布在多个虚拟机上时，web应用在所分布的每个虚拟机上都拥有一个ServletContext实例。缺省情况下，ServletContext不是分布式的，并且只存在于一个虚拟机上。<br>通过ServletContext可以访问应用范围的初始化参数和属性：</p><ol><li>初始化参数<br>ServletContext对象是在Web应用程序装载时初始化的。正像Servlet具有初始化参数一样，ServletContext也有初始化参数。Servlet上下文初始化参数指定应用程序范围内的信息。</li></ol><p>在web.xml中配置初始化参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">&lt;param-name&gt;adminEmail&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;webmaster&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br></pre></td></tr></table></figure></p><p><context-param>元素是针对整个应用的，所以并不嵌套在某个<servlet>元素中，该元素是<web-app>元 素的直接子元素。  </web-app></servlet></context-param></p><p>从Servlet中访问初始化参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ServletContext application=this.getServletContext();</span><br><span class="line">out.println(&quot;send us your&quot;)</span><br><span class="line">out.println(application.getInitParameter(&quot;email&quot;));</span><br><span class="line">out.println(&quot;&apos;&gt;email&quot;);</span><br></pre></td></tr></table></figure></p><ol start="2"><li>属性<br>可以通过编程的方式绑定，也可以作为web应用的全局变量被所有Servlet和JSPs访问</li></ol><p>设置Context属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServletContext application=this.getServletContext();</span><br><span class="line">application.setAttribute(&quot;person1&quot;,new Person(&quot;Jim&quot;));</span><br><span class="line">application.setAttribute(&quot;person2&quot;,new Person(&quot;Green&quot;));</span><br></pre></td></tr></table></figure></p><p>获取Context属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ServletContext application=this.getServletContext();</span><br><span class="line">Enumberation persons=application.getAttributeNames();</span><br><span class="line">while(persons.hasMoreElements())&#123;</span><br><span class="line">String name=(String)persons.nextElement();</span><br><span class="line">Person p=(Person)persons.getAttribute(name);</span><br><span class="line">application.removeAttribute(name);</span><br></pre></td></tr></table></figure></p><p>注：web应用范围具有以下两层含义：<br>（1） 表示有web应用的生命周期构成的时间段.<br>（2） 表示在web应用的生命周期内所有web组件的集合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">setAttribute(String name,java.lang.Objectobject)：</span><br><span class="line">把一个java 对象和一个属性名绑定，并存放到ServletContext 中，参数name 指定属性名，参数Object 表示共享数据。</span><br><span class="line"></span><br><span class="line">getAttribute(String name)：</span><br><span class="line">根据参数给定的属性名，返回一个Object类型的对象。</span><br><span class="line"></span><br><span class="line">getAttributeNames()：</span><br><span class="line">返回一个Enumeration 对象，该对象包含了所有存放在ServletContext 中的属性名</span><br><span class="line"></span><br><span class="line">removeAttribute(String name) ： </span><br><span class="line">根 据 参 数 指 定 的 属 性 名 ， 从servletContext 对象中删除匹配的属性。</span><br><span class="line"></span><br><span class="line">getRealPath（&quot;/&quot;）：</span><br><span class="line">得到绝对路径</span><br><span class="line">访问web应用的静态资源</span><br></pre></td></tr></table></figure></p><p>使用ServletContext接口可以直接访问web应用中的静态内容文档结构.包括HTML,GIF和JPEG文件。如以下方法:<br>.getResource<br>.getResourceAsStream<br>这两个方法的参数都是以”/“开头的字符串,表示资源相对于context根的相对路径.文档结构可以存在于服务器文件系统,或是war包中,或是在远程服务器上,抑或其他位置.不可以用来获得动态资源,比如,getResource(“/index.jsp”),这个方法将返回该jsp文件的源码,而不是动态页面.可以用”Dispatching</p><p>Requests”获得动态内容.<br>列出web应用中可被访问的资源,可以使用getResourcePaths（String path）方法。<br>跨多个请求，用户和Servlets<br>web服务器支持在一台机器上共享一个IP的多个逻辑主机,这种能力被称为”虚拟主机”,每个逻辑主机都拥有它自己的servlet context。servlet context不能跨虚拟主机共享。</p><h2 id="spring容器以及上下文"><a href="#spring容器以及上下文" class="headerlink" title="spring容器以及上下文"></a>spring容器以及上下文</h2><p>应用上下文即是Spring容器抽象的一种实现；而我们常见的ApplicationContext本质上说就是一个维护Bean定义以及对象之间协作关系的高级接口.<br>Spring的核心是容器，而容器并不唯一，框架本身就提供了很多个容器的实现，大概分为两种类型：一种是不常用的BeanFactory，这是最简单的容器，只能提供基本的DI功能；还有一种就是继承了BeanFactory后派生而来的应用上下文，其抽象接口也就是我们上面提到的的ApplicationContext，它能提供更多企业级的服务，例如解析配置文本信息等等，这也是应用上下文实例对象最常见的应用场景。有了上下文对象，我们就能向容器注册需要Spring管理的对象了。对于上下文抽象接口，Spring也为我们提供了多种类型的容器实现，供我们在不同的应用场景选择——</p><p>　　　 ① AnnotationConfigApplicationContext:从一个或多个基于java的配置类中加载上下文定义，适用于java注解的方式；</p><p>　　　　② ClassPathXmlApplicationContext:从类路径下的一个或多个xml配置文件中加载上下文定义，适用于xml配置的方式；</p><p>　　　　③ FileSystemXmlApplicationContext:从文件系统下的一个或多个xml配置文件中加载上下文定义，也就是说系统盘符中加载xml配置文件；</p><p>　　　　④ AnnotationConfigWebApplicationContext:专门为web应用准备的，适用于注解方式；</p><p>　　　　⑤ XmlWebApplicationContext:从web应用下的一个或多个xml配置文件加载上下文定义，适用于xml配置方式。</p><p>　　有了以上理解，问题就很好办了。你只要将你需要IOC容器替你管理的对象基于xml也罢，java注解也好，总之你要将需要管理的对象（Spring中我们都称之问bean）、bean之间的协作关系配置好，然后利用应用上下文对象加载进我们的Spring容器，容器就能为你的程序提供你想要的对象管理服务了。<br>　　到这儿就懂了idea报的这个配置默认的上下文的提示.其实也是过分纠结了,但是也知识整合了不少~<br><br>　　&gt;  关于这一点,更详细的解释<a href="https://www.cnblogs.com/chenbenbuyi/p/8166304.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenbenbuyi/p/8166304.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简单理解&quot;&gt;&lt;a href=&quot;#简单理解&quot; class=&quot;headerlink&quot; title=&quot;简单理解&quot;&gt;&lt;/a&gt;简单理解&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;context&lt;br&gt;在当前环境下你能拿到的参数都可以从context出发去拿,而不仅仅是放URL的.从里面可以
      
    
    </summary>
    
      <category term="Java" scheme="https://fzqeven.top/categories/Java/"/>
    
    
      <category term="上下文" scheme="https://fzqeven.top/tags/%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>代理模式,数组,迭代器|一点小细节</title>
    <link href="https://fzqeven.top/2019/02/18/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F,%E6%95%B0%E7%BB%84,%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%80%E7%82%B9%E5%B0%8F%E7%BB%86%E8%8A%82/"/>
    <id>https://fzqeven.top/2019/02/18/代理模式,数组,迭代器一点小细节/</id>
    <published>2019-02-18T06:12:06.545Z</published>
    <updated>2019-02-18T06:13:07.925Z</updated>
    
    <content type="html"><![CDATA[<p>要点以及遇到的问题:<br>1.代理模式增强功能<br>2.request.getParameterMap,底层源码给map加锁.map得值不可修改<br>3.解决:值放置到数组中时,遍历数组可修改.<br>注意:不能随便使用迭代器遍历修改.<br>引用数组修改的是内存地址中的实际参数,而for循环里面的局部变量为实际参数的副本,<br>修改其值不会修改实际的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">//过滤器</span><br><span class="line">package com.fzq.web.filter;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.annotation.WebFilter;</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">@WebFilter(&quot;/*&quot;)</span><br><span class="line">public class SensitiveWordsFilter implements Filter &#123;</span><br><span class="line">    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        //代理过滤</span><br><span class="line">        ServletRequest proxyObj = (ServletRequest) Proxy.newProxyInstance(req.getClass().getClassLoader(), req.getClass().getInterfaces(), new InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                //增强getParameter方法</span><br><span class="line">                //判断是否是getParameter方法</span><br><span class="line">                if (method.getName().equals(&quot;getParameter&quot;)) &#123;</span><br><span class="line">                    //增强返回值</span><br><span class="line">                    //获取返回值</span><br><span class="line">                    String value = (String) method.invoke(req, args);</span><br><span class="line">                    if (value != null) &#123;</span><br><span class="line">                        for (String s : list) &#123;</span><br><span class="line">                            if (value.contains(s)) &#123;</span><br><span class="line">                                value = value.replaceAll(s, &quot;***&quot;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    return value;</span><br><span class="line">                &#125; else if (method.getName().equals(&quot;getParameterValues&quot;)) &#123;</span><br><span class="line">                    String[] value = (String[]) method.invoke(req, args);</span><br><span class="line">                    for (int i = 0; i &lt; value.length; i++) &#123;</span><br><span class="line">                        if (value[i] != null) &#123;</span><br><span class="line">                            for (String s : list) &#123;</span><br><span class="line">                                if (value[i].contains(s)) &#123;</span><br><span class="line">                                    value[i] = value[i].replaceAll(s, &quot;***&quot;);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    return value;</span><br><span class="line"></span><br><span class="line">                &#125; else if(method.getName().equals(&quot;getParameterMap&quot;))&#123;</span><br><span class="line">                    Map&lt;String,String[]&gt; map = (Map&lt;String, String[]&gt;) method.invoke(req, args);</span><br><span class="line"></span><br><span class="line">                    if (map!=null)&#123;</span><br><span class="line">                        for (Map.Entry&lt;String, String[]&gt; entry : map.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">                            /**</span><br><span class="line">                             * 不能直接map.put使用修改覆盖的方法,map加锁无法修改</span><br><span class="line">                             */</span><br><span class="line">                            String[] values = entry.getValue();</span><br><span class="line">                            /**</span><br><span class="line">                             * emmmm呢</span><br><span class="line">                             * 不能使用迭代器!!</span><br><span class="line">                             * 迭代器新创建一个局部变量修改了值便销毁了</span><br><span class="line">                             * 修改value数组,引用传递,修改的是内存地址里面的值</span><br><span class="line">                             */</span><br><span class="line">                            for (int i = 0; i &lt; values.length; i++) &#123;</span><br><span class="line">                                for (String sensitiveWord : list) &#123;</span><br><span class="line">                                    if (values[i].contains(sensitiveWord))&#123;</span><br><span class="line">                                        values[i] = values[i].replaceAll(sensitiveWord,&quot;小可爱&quot;);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    /************************************************************</span><br><span class="line">                     * o98k</span><br><span class="line">                     Set&lt;String&gt; set = map.keySet();</span><br><span class="line">                    //获取key</span><br><span class="line">                    if(map!=null)&#123;</span><br><span class="line">                        for (String key : set) &#123;</span><br><span class="line">                            //value</span><br><span class="line">                            String[] value = map.get(key);</span><br><span class="line">                            //敏感词判断</span><br><span class="line">                            for (int i = 0; i &lt; value.length; i++) &#123;</span><br><span class="line">                                for (String sensitiveWords : list) &#123;</span><br><span class="line">                                    if (value[i].contains(sensitiveWords))&#123;</span><br><span class="line">                                        value[i] = value[i].replaceAll(sensitiveWords,&quot;小可爱&quot;);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                     ***************************************************/</span><br><span class="line">/*</span><br><span class="line">foolish  2.0</span><br><span class="line">                   Iterator&lt;Map.Entry&lt;String, String[]&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                    while(it.hasNext())&#123;</span><br><span class="line">                        String[] value = it.next().getValue();</span><br><span class="line">                        for (int i = 0; i &lt; value.length; i++) &#123;</span><br><span class="line">                            for (String s : list) &#123;</span><br><span class="line">                                if (value[i].contains(s))&#123;</span><br><span class="line">                                    value[i] = value[i].replaceAll(s,&quot;小可爱&quot;);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">*/</span><br><span class="line">/*</span><br><span class="line">//foolish 1.0</span><br><span class="line">                        if(value[0]!=null)&#123;</span><br><span class="line">                            for (String s : list) &#123;</span><br><span class="line">                                if(value[0].contains(s))&#123;</span><br><span class="line">                                    value[0]=value[0].replaceAll(s,&quot;***&quot;);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        return map;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                return method.invoke(req, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //放行</span><br><span class="line">        chain.doFilter(proxyObj,resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    public void init(FilterConfig config) throws ServletException &#123;</span><br><span class="line">        //获取文件真实路径</span><br><span class="line"></span><br><span class="line">        //读取文件</span><br><span class="line">        try &#123;</span><br><span class="line">            ServletContext servletContext = config.getServletContext();</span><br><span class="line">            String realPath = servletContext.getRealPath(&quot;/WEB-INF/classes/敏感词汇.txt&quot;);</span><br><span class="line">            BufferedReader br = new BufferedReader(new FileReader(realPath));</span><br><span class="line">            String line = null;</span><br><span class="line">            while ((line = br.readLine()) != null) &#123;</span><br><span class="line">                list.add(line);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            br.close();</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//test<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.fzq.web.servlet;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">@WebServlet(&quot;/testServlet&quot;)</span><br><span class="line">public class TestServlet extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">       /* String name = request.getParameter(&quot;name&quot;);</span><br><span class="line">        String msg = request.getParameter(&quot;msg&quot;);</span><br><span class="line">        System.out.println(name+&quot;:&quot;+msg);*/</span><br><span class="line"></span><br><span class="line">       //map</span><br><span class="line">        Map&lt;String, String[]&gt; map = request.getParameterMap();</span><br><span class="line">        for (Map.Entry&lt;String, String[]&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            String name = entry.getKey();</span><br><span class="line">            String[] msg = entry.getValue();</span><br><span class="line">            System.out.println(name+&quot;:&quot;+msg[0]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">        String name = request.getParameterValues(&quot;name&quot;)[0];</span><br><span class="line">        String msg = request.getParameterValues(&quot;msg&quot;)[0];</span><br><span class="line">        System.out.println(name+&quot;:&quot;+msg);</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        this.doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;要点以及遇到的问题:&lt;br&gt;1.代理模式增强功能&lt;br&gt;2.request.getParameterMap,底层源码给map加锁.map得值不可修改&lt;br&gt;3.解决:值放置到数组中时,遍历数组可修改.&lt;br&gt;注意:不能随便使用迭代器遍历修改.&lt;br&gt;引用数组修改的是内存地址
      
    
    </summary>
    
      <category term="Java" scheme="https://fzqeven.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>命令备忘</title>
    <link href="https://fzqeven.top/2019/02/18/%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98/"/>
    <id>https://fzqeven.top/2019/02/18/命令备忘/</id>
    <published>2019-02-18T06:09:41.619Z</published>
    <updated>2019-02-18T06:09:41.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mavende-web-功能新建速度慢"><a href="#mavende-web-功能新建速度慢" class="headerlink" title="mavende web 功能新建速度慢"></a>mavende web 功能新建速度慢</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设置archetypeCatalog为internal，</span><br><span class="line">archetypeCatalog表示插件使用的archetype元数据，</span><br><span class="line">不加此参数时默认为remote（指向maven中央仓库)，</span><br><span class="line">指定internal来表示指向maven-archetype-plugin内置的。</span><br></pre></td></tr></table></figure><p>idea maven 编码<br>maven–&gt;runner—&gt;<br>-DarchetypeCatalog=internal</p><h2 id="控制台乱码问题"><a href="#控制台乱码问题" class="headerlink" title="控制台乱码问题"></a>控制台乱码问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Dfile.encoding=gb2312</span><br><span class="line">控制台是不乱了,其他地方就乱了,反正不相干,找到解决办法再更新|mark</span><br></pre></td></tr></table></figure><h2 id="80端口被占用"><a href="#80端口被占用" class="headerlink" title="80端口被占用"></a>80端口被占用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure><h2 id="破解idea"><a href="#破解idea" class="headerlink" title="破解idea"></a>破解idea</h2><p>重装不启动输入才生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ThisCrackLicenseId-&#123;</span><br><span class="line">&quot;licenseId&quot;:&quot;ThisCrackLicenseId&quot;,</span><br><span class="line">&quot;licenseeName&quot;:&quot;Even&quot;,</span><br><span class="line">&quot;assigneeName&quot;:&quot;&quot;,</span><br><span class="line">&quot;assigneeEmail&quot;:&quot;1679400990@qq.com&quot;,</span><br><span class="line">&quot;licenseRestriction&quot;:&quot;For This Crack, Only Test! Please support genuine!!!&quot;,</span><br><span class="line">&quot;checkConcurrentUse&quot;:false,</span><br><span class="line">&quot;products&quot;:[</span><br><span class="line">&#123;&quot;code&quot;:&quot;II&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;DM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;AC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;RS0&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;WS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;DPN&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;RC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;PS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;DC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;RM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;CL&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;PC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;</span><br><span class="line">],</span><br><span class="line">&quot;hash&quot;:&quot;2911276/0&quot;,</span><br><span class="line">&quot;gracePeriodDays&quot;:7,</span><br><span class="line">&quot;autoProlongated&quot;:false&#125;</span><br></pre></td></tr></table></figure></p><h2 id="IDEA创建Web项目，解决无自动生成web-xml问题"><a href="#IDEA创建Web项目，解决无自动生成web-xml问题" class="headerlink" title="IDEA创建Web项目，解决无自动生成web.xml问题"></a>IDEA创建Web项目，解决无自动生成web.xml问题</h2><p><a href="https://blog.csdn.net/u010758410/article/details/78780144/" target="_blank" rel="noopener">https://blog.csdn.net/u010758410/article/details/78780144/</a></p><h2 id="webstorm2018破解-汉化"><a href="#webstorm2018破解-汉化" class="headerlink" title="webstorm2018破解|汉化"></a>webstorm2018破解|汉化</h2><p><a href="https://blog.csdn.net/voke_/article/details/76418116" target="_blank" rel="noopener">https://blog.csdn.net/voke_/article/details/76418116</a></p><p><a href="https://blog.csdn.net/qq_41927251/article/details/80191812" target="_blank" rel="noopener">https://blog.csdn.net/qq_41927251/article/details/80191812</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;mavende-web-功能新建速度慢&quot;&gt;&lt;a href=&quot;#mavende-web-功能新建速度慢&quot; class=&quot;headerlink&quot; title=&quot;mavende web 功能新建速度慢&quot;&gt;&lt;/a&gt;mavende web 功能新建速度慢&lt;/h2&gt;&lt;figu
      
    
    </summary>
    
      <category term="备忘" scheme="https://fzqeven.top/categories/%E5%A4%87%E5%BF%98/"/>
    
    
      <category term="备忘" scheme="https://fzqeven.top/tags/%E5%A4%87%E5%BF%98/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot | 基础十四篇整理以及理解 | 便于查阅</title>
    <link href="https://fzqeven.top/2019/02/18/SpringBoot--%E5%9F%BA%E7%A1%80%E5%8D%81%E5%9B%9B%E7%AF%87%E6%95%B4%E7%90%86%E4%BB%A5%E5%8F%8A%E7%90%86%E8%A7%A3--%E4%BE%BF%E4%BA%8E%E6%9F%A5%E9%98%85/"/>
    <id>https://fzqeven.top/2019/02/18/SpringBoot--基础十四篇整理以及理解--便于查阅/</id>
    <published>2019-02-18T06:07:14.497Z</published>
    <updated>2019-02-18T06:07:14.497Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot 连载(一) : 从环境建置到打包上线(附视频):<br><a href="https://mp.weixin.qq.com/s/3Fuo3QD27WOwPTd-9B2ztw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3Fuo3QD27WOwPTd-9B2ztw</a><br>SpringBoot 连载(二) : 场景启动器分析(附视频)<br><a href="https://mp.weixin.qq.com/s/y-omkM9ua2YJGU_6GueCFw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/y-omkM9ua2YJGU_6GueCFw</a><br>SpringBoot 连载(三) : 修改默认配置以及使用yml(附视频)<br><a href="https://mp.weixin.qq.com/s/3hz7zncZAWFIpNUISHDmsg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3hz7zncZAWFIpNUISHDmsg</a><br>SpringBoot 连载(四) : 占位符与利用Profile来快速切换环境(附视频)<br><a href="https://mp.weixin.qq.com/s/LB6aMw-1Fk_WkBjFRVffsQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/LB6aMw-1Fk_WkBjFRVffsQ</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profile快速切换运行环境:</span><br></pre></td></tr></table></figure><p>SpringBoot 连载(五) : 配置文件的加载顺序&amp;优先级(附视频)<br><a href="https://mp.weixin.qq.com/s/O_89JzgJbIPoehiRXzPm3w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/O_89JzgJbIPoehiRXzPm3w</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">项目内部的优先级</span><br><span class="line">SpringBoot启动会扫描以下位置的application.properties &amp; application.yml文件作为SpringBoot的默认配置文件,所有位置的文件都会被加载,高优先级配置内容会覆盖低优先级配置内容,各个配置文件中的参数会形成互补;</span><br><span class="line"></span><br><span class="line">优先级排序:</span><br><span class="line"></span><br><span class="line">1:-file:./config/;</span><br><span class="line"></span><br><span class="line">2:-file:./</span><br><span class="line"></span><br><span class="line">3:-classpath:/config/;</span><br><span class="line"></span><br><span class="line">4:-classpath:/</span><br><span class="line"></span><br><span class="line">这个列表按照优先级排序，</span><br><span class="line">也就是说，</span><br><span class="line">src/main/resources/config下application.properties</span><br><span class="line">覆盖src/main/resources下application.properties中相同的属性，</span><br><span class="line"></span><br><span class="line">此外，如果你在相同优先级位置同时有application.properties和application.yml，</span><br><span class="line">那么application.yml里面的属性就会覆盖application.properties里的属性</span><br></pre></td></tr></table></figure></p><p>SpringBoot 连载(六) : 自动配置原理(附视频)<br><a href="https://mp.weixin.qq.com/s/SFzKRiyzY0hM3f6owx75DA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/SFzKRiyzY0hM3f6owx75DA</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">通过SpringBootApplication往内翻</span><br><span class="line">注解继承结构如下一层套一层:</span><br><span class="line">@EnableAutoConfiguration;--&gt;@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line">* 重点就是这个类 AutoConfigurationImportSelector.class</span><br><span class="line">* 程式会通过这个类里面的selectImports方法</span><br><span class="line">* 扫描了一个文件叫:META-INF/spring.factories  </span><br><span class="line">* 程式会把所有jar下的这个文件都进行扫描.然后装配成properties对象,</span><br><span class="line">* 然后从该对象中加载:EnableAutoConfiguration.class所对应的值.</span><br><span class="line">* 然后把这些值加载到容器中去.这些值其他就是各种自动配置的组件类.</span><br><span class="line">* 不同的组件负责不同功能的自动配置.</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdnimg.cn/20190116153402820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjMwMjcw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>SpringBoot 连载(七) : 高性能日志记录(附视频)<br><a href="https://mp.weixin.qq.com/s/aI19nBcYPskI3QmNWux51Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/aI19nBcYPskI3QmNWux51Q</a><br>SpringBoot 连载(八) : 静态文件与模板引擎(附视频)<br><a href="https://mp.weixin.qq.com/s/4bgv7SDhSeQr0wsUbQz7rw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/4bgv7SDhSeQr0wsUbQz7rw</a><br>SpringBoot 连载(九) : MVC自动配置&amp;扩展,Boot 国际化(附视频)<br><a href="https://mp.weixin.qq.com/s/LmlIiq1TmQ28x6shFt7rwA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/LmlIiq1TmQ28x6shFt7rwA</a><br>SpringBoot 连载(十) : 拦截器与Thymeleaf共用模块(附视频)<br><a href="https://mp.weixin.qq.com/s/RfZIc-_t5e67UsY9uX9fFQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/RfZIc-_t5e67UsY9uX9fFQ</a><br>SpringBoot 连载(十一) : Restful方式实现CRUD(附视频)<br><a href="https://mp.weixin.qq.com/s/eSLMWgcf3YCbGmbSCSjGfg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/eSLMWgcf3YCbGmbSCSjGfg</a><br>SpringBoot 连载(十二) : 定制错误处理页面与消息(附视频)<br><a href="https://mp.weixin.qq.com/s/6lUL-zl95wmusxrOHV7uaw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/6lUL-zl95wmusxrOHV7uaw</a><br>SpringBoot 连载(十三) : Servlet容器与三大组件(附视频)<br><a href="https://mp.weixin.qq.com/s/4SRIUisK3tApAx8uVRoXZQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/4SRIUisK3tApAx8uVRoXZQ</a><br>SpringBoot 连载(十四) : SpringBoot项目模块化(结束篇)<br><a href="https://mp.weixin.qq.com/s/S_BIWxSVMlsPr_wrVPb7YQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/S_BIWxSVMlsPr_wrVPb7YQ</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SpringBoot 连载(一) : 从环境建置到打包上线(附视频):&lt;br&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/3Fuo3QD27WOwPTd-9B2ztw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:/
      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://fzqeven.top/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://fzqeven.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>二  |基于Linux系统使用docker搭建java环境|更改docker默认文件位置</title>
    <link href="https://fzqeven.top/2019/01/06/%E6%9C%8D%E5%8A%A1%E5%99%A8(2)/"/>
    <id>https://fzqeven.top/2019/01/06/服务器(2)/</id>
    <published>2019-01-06T11:54:52.536Z</published>
    <updated>2019-01-07T05:54:17.527Z</updated>
    
    <content type="html"><![CDATA[<p>折腾了一天,踩了巨多的坑,由于对Linux的挂载点不清楚,docker的相关文件存储位置也不知道,目录管理起来很麻烦,搜索了一些资料,下面将docker的默认位置从/usr/lib/docker移出去</p><h2 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h2><blockquote><p> 安装了xshell和xftp之后</p><p>使用docker来管理云简直太方便了,cool ~ ~</p><p>记录部分便于查阅</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> docker --help 查看docker帮助文档</span><br><span class="line"></span><br><span class="line"> systemctl start docker 启动docker</span><br><span class="line"> </span><br><span class="line"> systemctl stop docker  停止docker</span><br><span class="line"> </span><br><span class="line"> systemctl restart docker 重启docker</span><br><span class="line"> </span><br><span class="line"> systemctl enable docker 开机启动</span><br><span class="line"> ---------------------------------------------</span><br><span class="line"> docker ps 查看当前正在运行的容器</span><br><span class="line"></span><br><span class="line"> docker ps -a 查看所有容器的状态</span><br><span class="line"></span><br><span class="line"> docker start/stop id/name 启动/停止某个容器</span><br><span class="line"></span><br><span class="line"> docker attach id 进入某个容器(使用exit退出后容器也跟着停止运行)</span><br><span class="line"></span><br><span class="line"> docker exec -it 容器id（或者name） /bin/bash  启动一个伪终端以交互式的方式进入某个容器（使用exit退出后容器不停止运行）</span><br><span class="line"></span><br><span class="line"> docker images 查看本地镜像</span><br><span class="line"> docker rm id/name 删除某个容器</span><br><span class="line"> docker rmi id/name 删除某个镜像</span><br><span class="line">---------------------</span><br><span class="line">以上命令已经够用了,</span><br><span class="line">更多详细的学习,学习参考:</span><br><span class="line">https://yeasy.gitbooks.io/docker_practice/</span><br></pre></td></tr></table></figure><p>搭配daocloud图形化界面使用,连接上服务器直接操作docker的容器和镜像</p><p><a href="https://dashboard.daocloud.io" target="_blank" rel="noopener">https://dashboard.daocloud.io</a></p><h2 id="更改docker默认文件位置"><a href="#更改docker默认文件位置" class="headerlink" title="更改docker默认文件位置"></a>更改docker默认文件位置</h2><p>在/home 目录下创建目录.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home</span><br><span class="line">mkdir docker</span><br></pre></td></tr></table></figure><p>修改docker的systemd的 docker.service的配置文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure><p>在里面的EXECStart的后面增加后如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd --graph /home/docker</span><br></pre></td></tr></table></figure><p>修改前:</p><p><img src="/images/fuwuqidajian/fuwu21.png" alt="img"> </p><p>修改后:</p><p><img src="/images/fuwuqidajian/fuwu22.png" alt="img"> </p><p>如果docker是1.12或以上的版本，可以修改（或新建）daemon.json文件。修改后会立即生效，不需重启docker服务。</p><p> <strong>vim /etc/docker/daemon.json</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line"> &quot;registry-mirrors&quot;: [&quot;http://7e61f7f9.m.daocloud.io&quot;],&quot;graph&quot;: &quot;/home/docker&quot;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p> 资料链接,我使用的是方法2,有效      <a href="http://blog.51cto.com/12447922/2059793" target="_blank" rel="noopener">http://blog.51cto.com/12447922/2059793</a></p></blockquote><p>修改了之后使用docker info 查看一下是否修改成功</p><p><img src="/images/fuwuqidajian/1546764768795.png" alt="1546764768795"></p><p>用了一天的时间学习了docker详细指南和基本操作命令和反反复复踩了很多的坑,下面开始来配置javaweb环境.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;折腾了一天,踩了巨多的坑,由于对Linux的挂载点不清楚,docker的相关文件存储位置也不知道,目录管理起来很麻烦,搜索了一些资料,下面将docker的默认位置从/usr/lib/docker移出去&lt;/p&gt;
&lt;h2 id=&quot;docker常用命令&quot;&gt;&lt;a href=&quot;#do
      
    
    </summary>
    
      <category term="阿里云服务器" scheme="https://fzqeven.top/categories/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Linux" scheme="https://fzqeven.top/tags/Linux/"/>
    
      <category term="docker" scheme="https://fzqeven.top/tags/docker/"/>
    
      <category term="xshell/xftp" scheme="https://fzqeven.top/tags/xshell-xftp/"/>
    
  </entry>
  
  <entry>
    <title>一  |阿里云Linux服务器初建(工具:Xshell/xftp)</title>
    <link href="https://fzqeven.top/2019/01/06/%E6%9C%8D%E5%8A%A1%E5%99%A8(1)/"/>
    <id>https://fzqeven.top/2019/01/06/服务器(1)/</id>
    <published>2019-01-06T11:54:52.363Z</published>
    <updated>2019-01-06T13:55:39.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><blockquote><p>SSH:Secure Shell的缩写,安全外壳协议,是建立在应用层基础上的安全协议.是目前较为可靠,专为远程登录会话和其他网络服务提供安全性的协议.利用ssh协议可以有效防止远程管理过程中的信息泄漏问题.<br>Xshell   是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。Xshell 通过互联网到远程主机的安全连接以及它创新性的设计和特色帮助用户在复杂的网络环境中享受他们的工作。</p></blockquote><p>emmmm………</p><p>xshell和xftp界面好看,操作简单人性化,相比其他远程工具,这两个使用感受敲棒的~</p><h2 id="linux常用指令"><a href="#linux常用指令" class="headerlink" title="linux常用指令"></a>linux常用指令</h2><h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><blockquote><p>记录部分便于查阅</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd /home 进入目录</span><br><span class="line">cd .. 返回上一级目录</span><br><span class="line">cd ../.. 返回上两级目录</span><br><span class="line">cd 进入个人的主目录</span><br><span class="line">cd - 返回上次所在的目录</span><br><span class="line">pwd 显示工作路径</span><br><span class="line">ls 查看目录中的文件</span><br><span class="line">ll 查看目录中的文件(显示文件中的内容)</span><br><span class="line">ll -f 显示隐藏文件</span><br><span class="line">ll -a 显现隐藏文件(包括文件中的内容)</span><br></pre></td></tr></table></figure><p>Linux命令:</p><p><a href="https://www.cnblogs.com/yjd_hycf_space/p/7730690.html" target="_blank" rel="noopener">https://www.cnblogs.com/yjd_hycf_space/p/7730690.html</a></p><h2 id="服务器初建"><a href="#服务器初建" class="headerlink" title="服务器初建"></a>服务器初建</h2><ol><li><p>下载及安装Xshell和Xftp.</p><p>新手教程<img src="/images/0EABD8B4.png" alt="img"> :</p></li></ol><p><a href="https://blog.csdn.net/weixin_40928253/article/details/80621724" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40928253/article/details/80621724</a></p><p><a href="https://jingyan.baidu.com/article/ad310e800eec371848f49e52.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/ad310e800eec371848f49e52.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SSH&quot;&gt;&lt;a href=&quot;#SSH&quot; class=&quot;headerlink&quot; title=&quot;SSH&quot;&gt;&lt;/a&gt;SSH&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;SSH:Secure Shell的缩写,安全外壳协议,是建立在应用层基础上的安全协议.是目前较为可靠,专为
      
    
    </summary>
    
      <category term="阿里云服务器" scheme="https://fzqeven.top/categories/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Linux" scheme="https://fzqeven.top/tags/Linux/"/>
    
      <category term="xshell/xftp" scheme="https://fzqeven.top/tags/xshell-xftp/"/>
    
  </entry>
  
  <entry>
    <title>三  |基于Linux系统使用docker搭建java环境|mysql|Tomcat</title>
    <link href="https://fzqeven.top/2019/01/06/%E6%9C%8D%E5%8A%A1%E5%99%A8(3)/"/>
    <id>https://fzqeven.top/2019/01/06/服务器(3)/</id>
    <published>2019-01-06T11:54:52.361Z</published>
    <updated>2019-01-09T01:31:49.719Z</updated>
    
    <content type="html"><![CDATA[<p>1）yum 包更新到最新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure><p>（2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>（3）设置yum源为阿里云</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>（4）安装docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure><p>（5）安装后查看docker版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><p>  (6)  启动docker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>  (7)  开机启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p>设置国内的镜像,这里的daemon.json,没有这个文件要先创建.json文件</p><p><a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker" target="_blank" rel="noopener">https://lug.ustc.edu.cn/wiki/mirrors/help/docker</a></p><p>编辑该文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>在该文件中输入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里我将docker默认目录放在了/home/docker下,更改了默认目录还要加默认目录的位置</span><br><span class="line">//参见  搭建(二)</span><br></pre></td></tr></table></figure><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p>(查找Docker Hub上的mysql镜像,会列出各种镜像,选择自己想要的) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure><p>(拉取mysql 5.6版本的镜像,为什么不选择最新版本,因为5.7版本以后会需要设置认证,一般人不会去设置,会在连接的时候报一个错误,为了不必要的麻烦,我选择5.6版本)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.6</span><br></pre></td></tr></table></figure><p>启动MySQL镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=mysql -itd -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root mysql</span><br></pre></td></tr></table></figure><p>进入MySQL容器</p><p>运行  docker exec -it mysql /bin/bash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure><p>进入MySQL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行  mysql -uroot -p</span><br></pre></td></tr></table></figure></p><p>由于mysql中root执行绑定在了<code>localhost</code>，因此需要对root进行授权，代码如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;root&apos; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><p>截图如下:</p><p><img src="/images/fuwuqidajian/1546774751282.png" alt="1546774751282"></p><p>这时,使用Navicat连接3306端口,主机选择阿里云服务器的ip就可以连接了.</p><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><p>1.安装tomcat</p><p>与安装mysql类似，运行如下命令</p><p>docker pull tomcat<br>2.运行tomcat</p><p>docker run –name tomcat -p 8080:8080 -v $PWD/tomcat:/usr/local/tomcat/webapps -d tomcat  </p><p>参数说明：</p><p>-p 8080:8080：将容器的8080端口映射到主机的8080端口</p><p>-v $PWD/tomcat:/usr/local/tomcat/webapps：将主机中当前目录下的tomcat挂载到容器的/webapps</p><p>另外，tomcat的官方镜像中已经自带了jdk的环境，所以就不用特地去配置jdk的环境了。</p><h2 id="配置阿里云安全组规则-很重要"><a href="#配置阿里云安全组规则-很重要" class="headerlink" title="配置阿里云安全组规则|很重要!"></a>配置阿里云安全组规则|很重要!</h2><p>使用阿里云服务器还需要到阿里云控制台配置实例的安全组规则，否则无法从远端访问服务器,<br>官方提供了http80端口,mysql3306端口等常用端口。配置好了就可以在浏览器访问测试了!</p><h2 id="配置成功"><a href="#配置成功" class="headerlink" title="配置成功"></a>配置成功</h2><p><img src="/images/fuwuqidajian/1546775281397.png" alt="1546775281397"></p><p><img src="/images/fuwuqidajian/1546775314617.png" alt="1546775314617"></p><h2 id="喜大普奔"><a href="#喜大普奔" class="headerlink" title="喜大普奔!!"></a>喜大普奔!!</h2><p>踩了好多好多好多坑,闷头搞了一天,可以开始愉快的玩耍啦!!!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1）yum 包更新到最新&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="阿里云服务器" scheme="https://fzqeven.top/categories/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Linux" scheme="https://fzqeven.top/tags/Linux/"/>
    
      <category term="docker" scheme="https://fzqeven.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习(一)_六大原则</title>
    <link href="https://fzqeven.top/2018/11/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>https://fzqeven.top/2018/11/24/设计模式的六大原则/</id>
    <published>2018-11-24T02:09:56.525Z</published>
    <updated>2018-12-18T06:09:31.526Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h2><blockquote><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p></blockquote><p>设计模式主要是基于以下面向对象设计原则</p><ul><li>对接口编程而不是对实现编程</li><li>优先使用对象组合而不是继承</li></ul><h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><p>考软考的时候强行背下来,但是理解不深刻,索性还是自己整理学习一遍.23种设计模式则是遵循了这六大原则,达到了<strong>高内聚,低耦合</strong>,使程序<strong>可维护,可复用,可拓展</strong></p><h3 id="总原则、开闭原则（Open-Close-Principle）"><a href="#总原则、开闭原则（Open-Close-Principle）" class="headerlink" title="总原则、开闭原则（Open Close Principle）"></a><strong>总原则、开闭原则（Open Close Principle）</strong></h3><p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。</p><p><strong>[尽量不要更改源代码,而是在原有的基础上增加新的类—用抽象实现框架,用实现扩展细节]</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例:</span><br><span class="line">版本更新：尽量不更改源代码，可以增加新功能</span><br><span class="line"></span><br><span class="line">员工迟到问题：可以制定迟到的晚下班，迟到多久就得加班多久等制度</span><br><span class="line"></span><br><span class="line">即：上班总时长封闭，对于迟到一点开放</span><br></pre></td></tr></table></figure><p>在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。开闭原则具有理想主义色彩,想要达到这样的效果，我们需要使用接口和抽象类，在学习和理解设计模式的时候,则会更好更深刻的体会到这几个原则。</p><p>(菜鸟教程里把这一条替换了单一职责原则,而菜鸟付紫琴还Google了一下为什么菜鸟教程里面没有写单一职责原则….于是强行加进来,强行理解一下)</p><p>以下六条原则则是开闭原则的实现方法</p><h3 id="1、单一职责原则（Single-responsibility-principle）"><a href="#1、单一职责原则（Single-responsibility-principle）" class="headerlink" title="1、单一职责原则（Single responsibility principle）"></a><strong>1、单一职责原则</strong>（Single responsibility principle）</h3><p>又称单一功能原则,<strong>一个类应该只有一个发生变化的原因</strong>.每一个职责都是变化的一个轴线，如果一个类有一个以上的职责，这些职责就耦合在了一起。这会导致脆弱的设计。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响[复用性.例如：要实现逻辑和界面的分离。[高内聚,低耦合]</p><h3 id="2、里氏代换原则（Liskov-Substitution-Principle）"><a href="#2、里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="2、里氏代换原则（Liskov Substitution Principle）"></a><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></h3><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，<strong>任何基类可以出现的地方，子类一定可以出现</strong>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我的理解:</span><br><span class="line"></span><br><span class="line">- 扩展功能(例如update)时继承父类,尽量不要覆盖重写,</span><br><span class="line">- 重载父类的方法时,前置条件(即形参)要比父类的输入参数更宽松.</span><br><span class="line">- 实现抽象方法时,方法的后置条件(即返回值)要更严格.</span><br><span class="line"></span><br><span class="line">  否则会使原有功能发生故障</span><br></pre></td></tr></table></figure><p>设计模式中比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替.</p><p><strong>LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的特有的行为</strong>。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><h3 id="3、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#3、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="3、依赖倒转原则（Dependence Inversion Principle）"></a><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></h3><p><strong>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</strong></p><p>这个原则是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如:</span><br><span class="line">类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</span><br><span class="line"></span><br><span class="line">解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。</span><br></pre></td></tr></table></figure><h3 id="4、接口隔离原则（Interface-Segregation-Principle）"><a href="#4、接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="4、接口隔离原则（Interface Segregation Principle）"></a><strong>4、接口隔离原则（Interface Segregation Principle）</strong></h3><p>这个原则的意思是：<strong>类依赖于最小接口,否则实现了不需要的方法,耦合度也增高.使用多个隔离的接口，比使用单个接口要好</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如:</span><br><span class="line">客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 </span><br><span class="line">问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。</span><br><span class="line"></span><br><span class="line">解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</span><br></pre></td></tr></table></figure><p>它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><h3 id="5、迪米特法则，又称最少知道原则（Demeter-Principle）"><a href="#5、迪米特法则，又称最少知道原则（Demeter-Principle）" class="headerlink" title="5、迪米特法则，又称最少知道原则（Demeter Principle）"></a><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></h3><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。<strong>一个类对他所依赖的类知道的越少越好</strong></p><blockquote><p>[今天用到activeMQ时,突然理解了这个法则的应用场景,屁颠屁颠的来更新这篇笔记]<br>[这种知识突然连成一片儿的感觉超级nice啊哈哈哈]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">由于狭义迪米特法则要求两个类不必直接通信时,进行的方法调用应当由第三个类来转发调用.这样在系统中制造出大量的小方法,从而使系统显得凌乱.</span><br><span class="line">其可以使局部的模块得到简化,但是也会造成模块间的通信效率降低,使模块间不容易协调.</span><br><span class="line"></span><br><span class="line">但是迪米特法则讨论的是对象之间信息的流量,方向以及信息影响的控制.主要的意图是控制信息过载.要求一个模块应当尽可能的将自己的内部数据和实现细节隐藏起来,也就是要求有良好的封装性.</span><br><span class="line"></span><br><span class="line">另以今天理解JMS和activeMQ为例,JMS是消息服务的一组规范和接口,activeMQ则是JMS的实现.</span><br><span class="line">服务层和web层交互,模块间的依赖则存在一系列耦合关系.耦合越多,后期的维护工作则越难.改善模块间的调用关系.则应用到了消息中介,模块与模块之间互相不认识.消息的发送者和接收者互不影响,实现过程都被封装了.</span><br><span class="line">即回到六字箴言--&quot;高内聚,低耦合&quot;.</span><br></pre></td></tr></table></figure><blockquote><p>设计模式的门面模式(Facade) 和中介模式(Mediator),都是迪米特法则的应用.</p><p>啊哈,这两个模式还没有学习到,安排上了~</p></blockquote><p>迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。</p><h3 id="6、合成复用原则（Composite-Reuse-Principle）"><a href="#6、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6、合成复用原则（Composite Reuse Principle）"></a><strong>6、合成复用原则（Composite Reuse Principle）</strong></h3><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p><h2 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h2><p>根据设计模式的参考书 <strong>Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong> 中所提到的，总共有 23 种设计模式。</p><p>这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。</p><p>当然，我们还会讨论另一类设计模式：J2EE 设计模式。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">模式 &amp; 描述</th><th style="text-align:left">包括</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left"><strong>创建型模式</strong> <br>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</td><td style="text-align:left">工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left"><strong>结构型模式</strong><br> 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td style="text-align:left">适配器模式（Adapter Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left"><strong>行为型模式</strong> <br>这些设计模式特别关注对象之间的通信。</td><td style="text-align:left">责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left"><strong>J2EE 模式</strong> <br>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</td><td style="text-align:left">MVC 模式（MVC Pattern）<br>业务代表模式（Business Delegate Pattern）<br>组合实体模式（Composite Entity Pattern）<br>数据访问对象模式（Data Access Object Pattern）<br>前端控制器模式（Front Controller Pattern）<br>拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）<br>传输对象模式（Transfer Object Pattern）</td></tr></tbody></table><p>设计模式之间的关系</p><p><img src="http://www.runoob.com/wp-content/uploads/2014/08/the-relationship-between-design-patterns.jpg" alt="菜鸟教程_设计模式之间的关系"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;设计模式简介&quot;&gt;&lt;a href=&quot;#设计模式简介&quot; class=&quot;headerlink&quot; title=&quot;设计模式简介&quot;&gt;&lt;/a&gt;设计模式简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;设计模式是一套被反复使用的、多数人知晓的、经过分类编目的
      
    
    </summary>
    
      <category term="设计模式" scheme="https://fzqeven.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://fzqeven.top/tags/Java/"/>
    
      <category term="设计模式六大原则" scheme="https://fzqeven.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
      <category term="设计模式的三种类型+J2EE模式" scheme="https://fzqeven.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B-J2EE%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>idea调试功能</title>
    <link href="https://fzqeven.top/2018/11/22/idea%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD/"/>
    <id>https://fzqeven.top/2018/11/22/idea调试功能/</id>
    <published>2018-11-21T18:02:36.602Z</published>
    <updated>2018-11-23T02:28:04.020Z</updated>
    
    <content type="html"><![CDATA[<p>今天bug太多,要气死喵了,气到不想敲码,整理整理debug功能的使用,bug真是让人头秃,叉会儿腰!</p><h3 id="bug使我强-头-大-秃-debug功能"><a href="#bug使我强-头-大-秃-debug功能" class="headerlink" title="bug使我强(头)大(秃)!_debug功能"></a>bug使我强(头)大(秃)!_debug功能</h3><p>1.心平气和改bug!</p><p>2.扎实基础!(flag)</p><p>3.代码规范</p><p><img src="/images/idea调试.jpg" alt=""></p><h2 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h2><p><img src="/images/idea调试_01.png" alt="1542801420385"></p><h2 id="开启调试会话"><a href="#开启调试会话" class="headerlink" title="开启调试会话"></a>开启调试会话</h2><p>这只冒着绿光的小虫子</p><p><img src="/images/idea调试_02.png" alt="img"></p><p><img src="/images/idea调试_03.png" alt="1542803118466"></p><h2 id="单步调试"><a href="#单步调试" class="headerlink" title="单步调试"></a>单步调试</h2><ul><li><p>step over</p><p>程序向下执行一行(如果当前行有方法调用,这个方法将被执行完)</p></li><li><p>step into</p><p>如果该行有自定义的方法,则会进入自定义的方法(不会进入官方类库的方法)</p></li><li><p>force step into</p><p>该按钮在调试的时候能进入任何方法</p></li><li><p>step out</p><p>如果在调试的时候进入一个方法,并觉得没有问题,可以跳出该方法.</p><p>(之前笨的要死,一直step over到下一行)</p></li><li><p>drop frame</p><p>这个按钮返回到当前方法的调用处重新执行,并且上下文有关变量也会回到那个时候,只要调用链中还有上级方法,可以跳到任何一个方法</p></li></ul><p><img src="/images/idea调试_04.png" alt=""></p><h2 id="跨断点调试"><a href="#跨断点调试" class="headerlink" title="跨断点调试"></a>跨断点调试</h2><p>程序运行到下一个断点处,后面没有断点,则执行完程序</p><p><img src="/images/idea调试_05.png" alt="1542821550967"></p><h2 id="查看断点"><a href="#查看断点" class="headerlink" title="查看断点"></a>查看断点</h2><p>可以查看设置过的断点,设置断点的一些属性</p><p>可以设置条件断点（满足某个条件的时候，暂停程序的执行，如 c==97）。结束调试后，把所设的断点删除(选择要删除的断点后，点击上方的红色减号）</p><p><img src="/images/idea调试_06.png" alt="1542821976708"></p><h2 id="设置变量值"><a href="#设置变量值" class="headerlink" title="设置变量值"></a>设置变量值</h2><p>选中变量,右键setValue可以设置变量值.</p><p>(迷迷糊糊把idea关了,懒开了,睡吧睡吧付紫琴,晚安啦,明天再寻思寻思怎么高效的debug)</p><p><img src="/images/idea调试_07.png" alt="1542822584146"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天bug太多,要气死喵了,气到不想敲码,整理整理debug功能的使用,bug真是让人头秃,叉会儿腰!&lt;/p&gt;
&lt;h3 id=&quot;bug使我强-头-大-秃-debug功能&quot;&gt;&lt;a href=&quot;#bug使我强-头-大-秃-debug功能&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="这是一只小猫咪" scheme="https://fzqeven.top/categories/%E8%BF%99%E6%98%AF%E4%B8%80%E5%8F%AA%E5%B0%8F%E7%8C%AB%E5%92%AA/"/>
    
    
      <category term="Java" scheme="https://fzqeven.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习之策略模式 strategy pattern!</title>
    <link href="https://fzqeven.top/2018/11/17/strategy-pattern/"/>
    <id>https://fzqeven.top/2018/11/17/strategy-pattern/</id>
    <published>2018-11-16T18:05:19.000Z</published>
    <updated>2018-11-24T01:55:26.430Z</updated>
    
    <content type="html"><![CDATA[<p>面对这些有类似的属性但不同的行为的类来说，使用策略模式便有利于类的拓展，其原则是：多用组合，少用继承。</p><h2 id="图片图片图片图片没有没有没有显示显示显示显示显示"><a href="#图片图片图片图片没有没有没有显示显示显示显示显示" class="headerlink" title="图片图片图片图片没有没有没有显示显示显示显示显示"></a>图片图片图片图片没有没有没有显示显示显示显示显示</h2><h2 id="不困不困不困不困不困怎么办"><a href="#不困不困不困不困不困怎么办" class="headerlink" title="不困不困不困不困不困怎么办"></a>不困不困不困不困不困怎么办</h2><h2 id="上次上次上次都可以显示-为什么这次不显示不显示不显示"><a href="#上次上次上次都可以显示-为什么这次不显示不显示不显示" class="headerlink" title="上次上次上次都可以显示,为什么这次不显示不显示不显示"></a>上次上次上次都可以显示,为什么这次不显示不显示不显示</h2><h2 id="睡觉-晚安"><a href="#睡觉-晚安" class="headerlink" title="睡觉,晚安!"></a>睡觉,晚安!</h2><p><img src="/images/strategyPattern.png" alt="策略模式"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面对这些有类似的属性但不同的行为的类来说，使用策略模式便有利于类的拓展，其原则是：多用组合，少用继承。&lt;/p&gt;
&lt;h2 id=&quot;图片图片图片图片没有没有没有显示显示显示显示显示&quot;&gt;&lt;a href=&quot;#图片图片图片图片没有没有没有显示显示显示显示显示&quot; class=&quot;head
      
    
    </summary>
    
      <category term="设计模式" scheme="https://fzqeven.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://fzqeven.top/tags/Java/"/>
    
      <category term="设计模式" scheme="https://fzqeven.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="策略模式" scheme="https://fzqeven.top/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Oracle学习_01</title>
    <link href="https://fzqeven.top/2018/11/13/Oracle%E5%AD%A6%E4%B9%A0_01/"/>
    <id>https://fzqeven.top/2018/11/13/Oracle学习_01/</id>
    <published>2018-11-13T08:52:03.440Z</published>
    <updated>2018-11-16T18:00:54.013Z</updated>
    
    <content type="html"><![CDATA[<h4 id="创建表空间"><a href="#创建表空间" class="headerlink" title="创建表空间"></a>创建表空间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE tablespace fuziqin</span><br><span class="line">datafile &apos;c:\fuziqin.dbf&apos;</span><br><span class="line">size 100m</span><br><span class="line">autoextend on</span><br><span class="line">next 10m;</span><br></pre></td></tr></table></figure><h4 id="删除表空间"><a href="#删除表空间" class="headerlink" title="删除表空间"></a>删除表空间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop tablespace fuziqin</span><br></pre></td></tr></table></figure><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create user fuziqin</span><br><span class="line">identified by fuziqin</span><br><span class="line">default tablespace fuziqin</span><br></pre></td></tr></table></figure><h4 id="给用户授权"><a href="#给用户授权" class="headerlink" title="给用户授权"></a>给用户授权</h4><p>–oracle数据库中常用角色<br>connect–连接角色，基本角色<br>resource–开发者角色<br>dba–超级管理员角色</p><p>–给fuziqin授予dba角色<br><code>grant dba to fuziqin;</code></p><p>–切换到fuziiqn用户下,创建一个person表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table person(</span><br><span class="line">       pid number(20),</span><br><span class="line">       pname varchar2(10)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--添加一列</span><br><span class="line">alter table person add (gender number(1));</span><br><span class="line">--修改列类型</span><br><span class="line">alter table person modify gender char(1);</span><br><span class="line">--修改列名称</span><br><span class="line">alter table person rename column gender to sex;</span><br><span class="line">--删除一列</span><br><span class="line">alter table person drop column sex;</span><br></pre></td></tr></table></figure><h4 id="查询表中记录"><a href="#查询表中记录" class="headerlink" title="查询表中记录"></a>查询表中记录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select * from person</span><br><span class="line">--添加一条记录</span><br><span class="line">insert into person (pid,pname) values </span><br><span class="line">commit;</span><br><span class="line">--修改一条记录</span><br><span class="line">update person set pname = &apos;王昱珩&apos; where pid = 1;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><h4 id="三个删除"><a href="#三个删除" class="headerlink" title="三个删除"></a>三个删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--删除表中全部记录</span><br><span class="line">delete from person;</span><br><span class="line">--删除表结构</span><br><span class="line">drop table person;</span><br><span class="line">--先删除表，再次创建表。效果等同于删除表中全部记录。</span><br><span class="line">--在数据量大的情况下，尤其在表中带有索引的情况下，该操作效率高。</span><br><span class="line">--索引可以提供查询效率，但是会影响增删改效率。</span><br><span class="line">truncate table person;</span><br></pre></td></tr></table></figure><hr><h4 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h4><p>序列不真的属于任何一张表,但是可以逻辑和表做绑定</p><p>序列:默认从1开始,依次递增,主要用来给主键赋值使用</p><p>dual:虚表,只是为了补全语法,没有任何意义</p><blockquote><p>创建序列<br>​    语法 CREATE SEQUENCE 序列名 [相关参数]<br>参数说明<br>​    INCREMENT BY :序列变化的步进，负值表示递减。(默认1)<br>​    START WITH:序列的初始值 。(默认1)<br>​    MAXvalue:序列可生成的最大值。(默认不限制最大值，NOMAXVALUE)<br>​    MINVALUE:序列可生成的最小值。(默认不限制最小值，NOMINVALUE)<br>​    CYCLE:用于定义当序列产生的值达到限制值后是否循环(NOCYCLE:不循环，CYCLE:循环)。<br>​    CACHE:表示缓存序列的个数，数据库异常终止可能会导致序列中断不连续的情况，默认值为20，如果不使用缓存可设置NOCACHE<br>例<br>​    CREATE SEQUENCE SEQ_DEMO<br>​    INCREMENT BY 1<br>​    START WITH 1<br>​    NOMAXvalue<br>​    NOCYCLE<br>​    NOCACHE;</p></blockquote><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">create sequence s_person;</span><br><span class="line"></span><br><span class="line">--nextval :取得序列的下一个内容</span><br><span class="line">--currval :取得序列的当前内容</span><br><span class="line">select s_person.nextval from dual;</span><br><span class="line">select s_person.currval from dual;</span><br><span class="line"></span><br><span class="line">insert into person (pid ,pname) values (s_person.nextval,&apos;华晨宇&apos;);</span><br><span class="line">commit;</span><br><span class="line">SELECT * from person;</span><br><span class="line"></span><br><span class="line">nextval :取得序列的下一个内容</span><br><span class="line">currval :取得序列的当前内容</span><br><span class="line">select seqpersonid.nextval from dual;</span><br><span class="line">select s_person.currval from dual;</span><br></pre></td></tr></table></figure><h4 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--解锁scott用户，密码tiger</span><br><span class="line">alter user scott account unlock;</span><br><span class="line">--解锁scott用户的密码【此句也可以用来重置密码】</span><br><span class="line">alter user scott identified by tiger;</span><br></pre></td></tr></table></figure><h4 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h4><p>作用于一行,返回一个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--字符函数</span><br><span class="line">select upper(&apos;yes&apos;) from dual;--YES</span><br><span class="line">select lower(&apos;YES&apos;) from dual;--yes</span><br><span class="line">--数值函数</span><br><span class="line">select round(56.16, -2) from dual;---四舍五入，后面的参数表示保留的位数</span><br><span class="line">select trunc(56.16, -1) from dual;---直接截取，不在看后面位数的数字是否大于5.</span><br><span class="line">select mod(10, 3) from dual;---求余数</span><br></pre></td></tr></table></figure><h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--查询出emp表中所有员工入职距离现在几天。</span><br><span class="line">select sysdate-e.hiredate from emp e;</span><br><span class="line">--算出明天此刻</span><br><span class="line">select sysdate+1 from dual;</span><br><span class="line">--查询出emp表中所有员工入职距离现在几月。</span><br><span class="line">select months_between(sysdate,e.hiredate) from emp e;</span><br><span class="line">--查询出emp表中所有员工入职距离现在几年。</span><br><span class="line">select months_between(sysdate,e.hiredate)/12 from emp e;</span><br><span class="line">--查询出emp表中所有员工入职距离现在几周。</span><br><span class="line">select round((sysdate-e.hiredate)/7) from emp e;</span><br></pre></td></tr></table></figure><h4 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h4><blockquote><p>to_date(“要转换的字符串”,”转换的格式”)   两个参数的格式必须匹配，否则会报错。</p><p>即按照第二个参数的格式解释第一个参数。</p><p>to_char(日期,”转换格式” ) 即把给定的日期按照“转换格式”转换。</p><p>转换的格式：</p><p>表示year的：y  表示年的最后一位 yy 表示年的最后2位 yyy 表示年的最后3位 yyyy 用4位数表示年</p><p>表示month的：mm 用2位数字表示月；mon 用简写形式 比如11月或者nov ；month 用全称 比如11月或者november</p><p>表示day的：dd 表示当月第几天；ddd表示当年第几天；dy 当周第几天 简写  比如星期五或者fri；day当周第几天 全写</p><p>比如星期五或者friday。</p><p>表示hour的：hh 2位数表示小时 12进制； hh24 2位数表示小时 24小时</p><p>表示minute的：mi 2位数表示分钟</p><p>表示second的：ss 2位数表示秒 60进制</p><p>表示季度的：q 一位数 表示季度 （1-4）</p><p>另外还有ww 用来表示当年第几周 w用来表示当月第几周。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--日期转字符串</span><br><span class="line">select to_char(sysdate, &apos;fm yyyy-mm-dd hh24:mi:ss&apos;) from dual;</span><br><span class="line">--字符串转日期</span><br><span class="line">select to_date(&apos;2018-6-7 16:39:50&apos;, &apos;fm yyyy-mm-dd hh24:mi:ss&apos;) from dual;</span><br></pre></td></tr></table></figure><h4 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--算出emp表中所有员工的年薪</span><br><span class="line">--奖金里面有null值，如果null值和任意数字做算术运算，结果都是null。</span><br><span class="line">select e.sal*12+nvl(e.comm, 0) from emp e;</span><br></pre></td></tr></table></figure><h4 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h4><p>mysql和Oracle通用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">--给emp表员工取中文名</span><br><span class="line"></span><br><span class="line">select e.ename, </span><br><span class="line">       case e.ename</span><br><span class="line">         when &apos;SMITH&apos; then &apos;华晨宇&apos;</span><br><span class="line">           when &apos;ALLEN&apos; then &apos;王昱珩&apos;</span><br><span class="line">             when &apos;WARD&apos; then &apos;李健&apos;</span><br><span class="line">               --else &apos;付紫琴&apos;</span><br><span class="line">                 end</span><br><span class="line">from emp e;</span><br><span class="line"></span><br><span class="line">--判断emp表中员工工资，如果高于3000显示高收入，如果高于1500低于3000显示中等收入，</span><br><span class="line">--其余显示低收入</span><br><span class="line">select e.sal, </span><br><span class="line">       case </span><br><span class="line">         when e.sal&gt;3000 then &apos;高收入&apos;</span><br><span class="line">           when e.sal&gt;1500 then &apos;中等收入&apos;</span><br><span class="line">               else &apos;低收入&apos;</span><br><span class="line">                 end</span><br><span class="line">from emp e;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p> oracle中除了起别名，都用单引号。</p></blockquote></blockquote><p>oracle专用条件表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select e.ename, </span><br><span class="line">        decode(e.ename,</span><br><span class="line">          &apos;SMITH&apos;,  &apos;华晨宇&apos;,</span><br><span class="line">            &apos;ALLEN&apos;,  &apos;王昱珩&apos;,</span><br><span class="line">              &apos;WARD&apos;,  &apos;李健&apos;,</span><br><span class="line">                &apos;喵&apos;) &quot;中文名&quot;             </span><br><span class="line">from emp e;</span><br></pre></td></tr></table></figure><h4 id="多行函数"><a href="#多行函数" class="headerlink" title="多行函数"></a>多行函数</h4><p>【聚合函数】：作用于多行，返回一个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select count(1) from emp;---查询总数量</span><br><span class="line">select sum(sal) from emp;---工资总和</span><br><span class="line">select max(sal) from emp;---最大工资</span><br><span class="line">select min(sal) from emp;---最低工资</span><br><span class="line">select avg(sal) from emp;---平均工资</span><br></pre></td></tr></table></figure><h4 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h4><p>–查询出每个部门的平均工资<br>–分组查询中,出现group by后面的原始列,才能出现在select后面<br>–没有出现在group by后面的列,想在select后面,必须加上聚合函数<br>–聚合函数有一个特性,可以把多行记录变成一个值.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">e.deptno,</span><br><span class="line">avg( e.sal ) </span><br><span class="line">FROM</span><br><span class="line">emp e </span><br><span class="line">GROUP BY</span><br><span class="line">e.deptno;</span><br></pre></td></tr></table></figure><p>–查出平均工资高于2000的部门信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">e.DEPTNO,</span><br><span class="line">avg( e.sal ) asal </span><br><span class="line">FROM</span><br><span class="line">emp e </span><br><span class="line">GROUP BY e.DEPTNO</span><br><span class="line">having avg(e.sal)&gt;2000;</span><br></pre></td></tr></table></figure><p>–所有条件都不能使用别名来判断.</p><p>例:select ename ,sal s from emp where sal&gt;1500;</p><p>–查询出每个部门工资高于800的员工的平均工资</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">e.DEPTNO,</span><br><span class="line">avg( e.sal ) asal </span><br><span class="line">FROM</span><br><span class="line">emp e </span><br><span class="line">WHERE</span><br><span class="line">e.sal &gt; 800 </span><br><span class="line">GROUP BY</span><br><span class="line">e.DEPTNO;</span><br></pre></td></tr></table></figure><hr><p>where是过滤分组前的数据,having是过滤分组后的数据.where必须在group by之前,having是在group by 之后.</p><hr><p>查询出每个部门高出800工资的员工的平均工资,然后再查出平均工资高于2000的部门</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">e.DEPTNO,</span><br><span class="line">avg( e.sal ) asal </span><br><span class="line">FROM</span><br><span class="line">emp e </span><br><span class="line">WHERE</span><br><span class="line">e.sal &gt; 800 </span><br><span class="line">GROUP BY</span><br><span class="line">e.DEPTNO </span><br><span class="line">HAVING</span><br><span class="line">avg( e.SAL ) &gt; 2000;</span><br></pre></td></tr></table></figure><h4 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h4><h5 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">* </span><br><span class="line">FROM</span><br><span class="line">emp e,</span><br><span class="line">dept d ;</span><br></pre></td></tr></table></figure><h5 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">* </span><br><span class="line">FROM</span><br><span class="line">emp e,</span><br><span class="line">dept d </span><br><span class="line">WHERE</span><br><span class="line">e.deptno = d.deptno;</span><br></pre></td></tr></table></figure><h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">* </span><br><span class="line">FROM</span><br><span class="line">emp e,</span><br><span class="line">dept d </span><br><span class="line">WHERE</span><br><span class="line">e.DEPTNO = d.DEPTNO;</span><br></pre></td></tr></table></figure><h5 id="右外连接-右边的表不加限制"><a href="#右外连接-右边的表不加限制" class="headerlink" title="右外连接(右边的表不加限制)"></a>右外连接(右边的表不加限制)</h5><p>–查询出所有的部门,以及部门下的员工信息.[外连接]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">* </span><br><span class="line">FROM</span><br><span class="line">emp e</span><br><span class="line">RIGHT JOIN dept d ON e.DEPTNO = d.DEPTNO;</span><br></pre></td></tr></table></figure></p><h5 id="左外连接-左边的表不加限制"><a href="#左外连接-左边的表不加限制" class="headerlink" title="左外连接(左边的表不加限制)"></a>左外连接(左边的表不加限制)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">* </span><br><span class="line">FROM</span><br><span class="line">emp e</span><br><span class="line">LEFT JOIN dept d ON e.DEPTNO = d.DEPTNO;</span><br></pre></td></tr></table></figure><h5 id="Oracle专用外连接-写在哪边-哪边就是匹配表"><a href="#Oracle专用外连接-写在哪边-哪边就是匹配表" class="headerlink" title="Oracle专用外连接(+写在哪边,哪边就是匹配表)"></a>Oracle专用外连接(+写在哪边,哪边就是匹配表)</h5><hr><p>几点注意:<br>1.放在等号左右都可,需要放在缺少信息的那一边<br>2.改符号仅适用于列,不能用在表达式上<br>3.不能和on和in操作符一起使用<br>4.全外连接不能使用</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">* </span><br><span class="line">FROM</span><br><span class="line">emp e,dept d</span><br><span class="line">where e.DEPTNO(+)=d.DEPTNO;</span><br></pre></td></tr></table></figure><h5 id="全外连接-左表和右表都不受限制"><a href="#全外连接-左表和右表都不受限制" class="headerlink" title="全外连接(左表和右表都不受限制)"></a>全外连接(左表和右表都不受限制)</h5><p>所有记录都显示,两表不足的地方均为null.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">* </span><br><span class="line">FROM</span><br><span class="line">emp e</span><br><span class="line">FULL JOIN dept d ON e.DEPTNO = d.DEPTNO;</span><br></pre></td></tr></table></figure></p><p>查询出员工姓名,员工领导姓名,员工部门,员工领导部门</p><h5 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h5><p>自连接其实就是站在不同角度把一张表看成多张表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">e1.ENAME,</span><br><span class="line">e2.ENAME </span><br><span class="line">FROM</span><br><span class="line">emp e1,</span><br><span class="line">emp e2,</span><br><span class="line">dept d1,</span><br><span class="line">dept d2 </span><br><span class="line">WHERE</span><br><span class="line">e1.DEPTNO = d1.DEPTNO </span><br><span class="line">AND e1.mgr = e2.EMPNO </span><br><span class="line">AND e2.DEPTNO = d2.DEPTNO;</span><br></pre></td></tr></table></figure></p><h5 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h5><h6 id="返回一个值"><a href="#返回一个值" class="headerlink" title="返回一个值"></a>返回一个值</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--查询出工资和SCOTT一样的员工信息</span><br><span class="line">SELECT</span><br><span class="line">* </span><br><span class="line">FROM</span><br><span class="line">emp </span><br><span class="line">WHERE</span><br><span class="line">sal IN (</span><br><span class="line">SELECT</span><br><span class="line">sal </span><br><span class="line">FROM</span><br><span class="line">emp </span><br><span class="line">WHERE</span><br><span class="line">ename = &apos;SCOTT&apos;)</span><br></pre></td></tr></table></figure><h6 id="返回一个集合"><a href="#返回一个集合" class="headerlink" title="返回一个集合"></a>返回一个集合</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--查询出工资和10号部门任意员工一样的员工信息</span><br><span class="line">SELECT</span><br><span class="line">* </span><br><span class="line">FROM</span><br><span class="line">emp </span><br><span class="line">WHERE</span><br><span class="line">sal IN ( SELECT sal FROM emp WHERE DEPTNO = 10 );</span><br></pre></td></tr></table></figure><h6 id="子查询返回一张表"><a href="#子查询返回一张表" class="headerlink" title="子查询返回一张表"></a>子查询返回一张表</h6><p>–查询出每个部门的最低工资和最低工资员工姓名,和该员工所在部门名称</p><ul><li>先查询出每个部门最低工资</li><li>三表联查,得到最终结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">t.DEPTNO,</span><br><span class="line">t.msal,</span><br><span class="line">e.ENAME,</span><br><span class="line">d.DNAME </span><br><span class="line">FROM</span><br><span class="line">( SELECT DEPTNO, min( sal ) msal FROM emp GROUP BY DEPTNO ) t,</span><br><span class="line">emp e,</span><br><span class="line">dept d </span><br><span class="line">WHERE</span><br><span class="line">t.deptno = e.deptno </span><br><span class="line">AND t.msal = e.sal </span><br><span class="line">AND e.deptno = d.deptno;</span><br></pre></td></tr></table></figure><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>rownum行号:当我们做select操作的时候,每查询出一行记录,就会在该行上加一个行号,</p><p>行号从1开始,依次递增,不能跳序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">--排序操作会影响rownum的顺序</span><br><span class="line">select rownum, e.* from emp e order by e.sal desc</span><br><span class="line">--如果涉及到排序，但是还要使用rownum的话，我们可以再次嵌套查询。</span><br><span class="line">SELECT ROWNUM</span><br><span class="line">,</span><br><span class="line">t.* </span><br><span class="line">FROM</span><br><span class="line">( SELECT ROWNUM, e.* FROM EMP e ORDER BY e.sal DESC ) t;</span><br><span class="line"></span><br><span class="line">--emp表工资倒叙排列后，每页五条记录，查询第二页。</span><br><span class="line">--rownum行号不能写上大于一个正数。</span><br><span class="line">SELECT</span><br><span class="line">* </span><br><span class="line">FROM</span><br><span class="line">( SELECT ROWNUM rn, tt.* FROM ( SELECT * FROM emp ORDER BY sal DESC ) tt WHERE ROWNUM &lt; 11 ) </span><br><span class="line">WHERE</span><br><span class="line">rn &gt;5</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;创建表空间&quot;&gt;&lt;a href=&quot;#创建表空间&quot; class=&quot;headerlink&quot; title=&quot;创建表空间&quot;&gt;&lt;/a&gt;创建表空间&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
      <category term="数据库" scheme="https://fzqeven.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Oracle" scheme="https://fzqeven.top/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Oracle学习_02</title>
    <link href="https://fzqeven.top/2018/11/13/Oracle%E5%AD%A6%E4%B9%A0_02/"/>
    <id>https://fzqeven.top/2018/11/13/Oracle学习_02/</id>
    <published>2018-11-13T06:34:04.191Z</published>
    <updated>2018-11-17T07:33:10.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>概念:视图就是提供一个查询的窗口,所有数据来自于原表</p><pre><code>--查询语句创建表create view v_emp as select * from scott.emp;--创建视图[必须要有dba权限]create view v_emp as select ename,job from emp;--查询视图select v_emp ;--修改视图[不推荐使用]update v_emp set job=&apos;CLERK&apos; where ename=&apos;ALLEN&apos;;commit;--创建只读视图create view v_emp1 as select ename ,job from emp with read only;</code></pre><p>–视图的作用:</p><p>–1.视图可以屏蔽掉一些敏感字段</p><p>–2.保证总部和分部数据及时统一</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>–概念:</p><p>–索引就是在表的列上构建一个二叉树,达到大幅度提高查询效率的目的,但是索引会影响增删改的效率</p><p>–类似于数组,以下标的形式去存储和访问表中的数据,索引可以是不连续的</p><blockquote><p>索引索引索引,待更biubiubiubiubiuMark</p></blockquote><h3 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--创建单列索引</span><br><span class="line"></span><br><span class="line">create index idx_ename on emp(ename);</span><br><span class="line"></span><br><span class="line">--单列索引触发规则,条件必须是索引列的原始值.</span><br><span class="line"></span><br><span class="line">--单行函数,模糊查询,都会影响索引的触发</span><br><span class="line"></span><br><span class="line">select * from emp where ename=&apos;SCOTT&apos;</span><br><span class="line"></span><br><span class="line">--复合索引</span><br><span class="line"></span><br><span class="line">--创建复合索引</span><br><span class="line"></span><br><span class="line">create index idx_enamejob on emp(ename,job);</span><br></pre></td></tr></table></figure><h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><p>–复合索引中第一列为优先检索列</p><p>–如果想要触发复合索引,必须包含有优先搜索列中的原始值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where ename =&apos;SCOTT&apos; and job=&apos;XX&apos;;  --触发复合索引</span><br><span class="line"></span><br><span class="line">select * from emp where ename =&apos;SCOTT&apos; or job=&apos;XX&apos;;  --不触发索引</span><br><span class="line"></span><br><span class="line">select * from emp where ename =&apos;SCOTT&apos;  --触发单列索引</span><br></pre></td></tr></table></figure><hr><h2 id="pl-sql编程语言"><a href="#pl-sql编程语言" class="headerlink" title="pl/sql编程语言"></a>pl/sql编程语言</h2><p>–是对sql语言的扩展,似的sql语言具有过程化编程的特性.比一般的过程化编程语言更加灵活高效.</p><p>–主要用来编写存储过程和存储函数等</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>–声明方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">declare</span><br><span class="line">i number(2)  := 10;</span><br><span class="line"></span><br><span class="line">s varchar2(10) := &apos;小明&apos;;</span><br><span class="line"></span><br><span class="line">ena emp.ename%type;  --引用型变量</span><br><span class="line"></span><br><span class="line">emprow emp%rowtype; --记录型变量</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line">dbms_output.put_line(i);</span><br><span class="line"></span><br><span class="line">dbms_output.put_line(s);</span><br><span class="line"></span><br><span class="line">select ename into ena from emp where empno = 7788;</span><br><span class="line"></span><br><span class="line">dbms_output.put_line(ena);</span><br><span class="line"></span><br><span class="line">select  * into emprow from emp where empno = 7788;</span><br><span class="line"></span><br><span class="line">dbms_output.put_line(emprow.ename|| &apos;的工作为:&apos; ||emprow.job);</span><br><span class="line"></span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>–pl/sql中的if判断</p><p>​    –输入小于18的数字,输出未成年</p><p>​    –输入大于18小于40的数字,输出中年人</p><p>​    –输入大于40的数字,输出老年人</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">i NUMBER ( 3 ) := &amp;ii;</span><br><span class="line">BEGIN</span><br><span class="line">IF</span><br><span class="line">i &lt; 18 THEN</span><br><span class="line">dbms_output.put_line ( &apos;未成年&apos; );</span><br><span class="line">elseif i &lt; 40 THEN</span><br><span class="line">dbms_output.put_line ( &apos;中年人&apos; );</span><br><span class="line">ELSE dbms_output.put_line ( &apos;未成年&apos; );</span><br><span class="line">END IF;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>–pl/sql中的loop循环<br>–用三种方式输出1到10是个数字<br>–while循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">i NUMBER ( 2 ) := 1;</span><br><span class="line">BEGIN</span><br><span class="line">while i &lt; 11 loop</span><br><span class="line">dbms_output.put_line ( i );</span><br><span class="line">i := i + 1;</span><br><span class="line">END loop;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>–exit循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DECLARE </span><br><span class="line">i NUMBER ( 2 ) := 1;</span><br><span class="line">BEGIN </span><br><span class="line">loop </span><br><span class="line">exit WHEN i &gt; 10;</span><br><span class="line">dbms_output.put_line ( i );</span><br><span class="line">i := i + 1;</span><br><span class="line">END loop;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>–for循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">declare</span><br><span class="line">begin</span><br><span class="line">for i in 1..10 loop</span><br><span class="line">dbms_output.put_line(i);</span><br><span class="line">end loop;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>–游标:游标(cursor)是系统为用户开设的一个数据缓冲区,存放SQL语句的执行结果,</p></blockquote></blockquote><p>–通俗的说:游标是一段内存区域,用于暂时存放sql语句受影响的数据.将这些数据放到一个内存区域的虚表中,而这个虚表就是游标</p><blockquote><blockquote><p>–作用:</p></blockquote></blockquote><blockquote><blockquote><p>1.数据库是具有回滚功能的，游标在其中有重要的作用。由于对数据库的操作会暂时放在游标中，只要在提交的时候出现异常，我们就可以根据游标就行回滚，在一定意义上有利于数据库的安全。</p></blockquote></blockquote><blockquote><blockquote><p>2.在Oracle中，PL/SQL只能返回单行数据，而游标的出现，可以返回多条数据。</p></blockquote></blockquote><p>–游标一旦关闭，游标占用的资源就被释放，游标变成无效，必须重新打开才能使用。 </p><p>–输出emp表中所有的员工的姓名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DECLARE </span><br><span class="line">cursor c1 IS SELECT * FROM emp;</span><br><span class="line">emprow emp % rowtype;</span><br><span class="line">BEGIN</span><br><span class="line">open c1;</span><br><span class="line">loop</span><br><span class="line">FETCH c1 INTO emprow;</span><br><span class="line">exit </span><br><span class="line">WHEN c1 % notfound;</span><br><span class="line">dbms_output.put_line ( emprow.ename );</span><br><span class="line"></span><br><span class="line">END loop;</span><br><span class="line">close c1;</span><br><span class="line"></span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>–给指定部门员工涨工资</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">declare</span><br><span class="line">--定义游标</span><br><span class="line">cursor c2(eno emp.deptno%type)</span><br><span class="line">is select empno from emp where deptno = eno;</span><br><span class="line">en emp.empno%type;</span><br><span class="line">begin</span><br><span class="line">--打开游标</span><br><span class="line">open c2(10);</span><br><span class="line">loop</span><br><span class="line">--提取游标</span><br><span class="line">fetch c2 into en;</span><br><span class="line">exit when c2%notfound;</span><br><span class="line">update emp set sal=sal+100 where empno=en;</span><br><span class="line">commit;</span><br><span class="line">end loop;</span><br><span class="line">--关闭游标</span><br><span class="line">close c2;</span><br><span class="line">end;</span><br><span class="line">--查询10号部门员工信息</span><br><span class="line">select * from emp where deptno = 10;</span><br></pre></td></tr></table></figure><p>–存储过程</p><p>–存储过程:存储过程就是提前已经编译好的一段pl/sql语言,放置在数据库端</p><p>–可以直接被调用.这一段pl/sql一般都是固定步骤的业务</p><p>–给指定员工涨100块钱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">create procedure p1(eno emp.empno%type)</span><br><span class="line">is</span><br><span class="line">begin </span><br><span class="line">update emp set sal=sal+100 where empno = eno;</span><br><span class="line">commit;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">select * from emp where empno = 7788;</span><br><span class="line">--测试p1</span><br><span class="line">declare</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">p1(7788);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>–通过存储函数实现员工的年薪</p><p>–存储过程和存储函数的参数都不能带长度</p><p>–存储函数的返回值类型不能带长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CREATE </span><br><span class="line">OR REPLACE FUNCTION f_yearsal ( eno emp.empno % TYPE ) return NUMBER IS s NUMBER ( 10 );</span><br><span class="line">BEGIN</span><br><span class="line">SELECT</span><br><span class="line">sal * 12+nvl ( comm, 0 ) INTO s </span><br><span class="line">FROM</span><br><span class="line">emp </span><br><span class="line">WHERE</span><br><span class="line">empno = eno;</span><br><span class="line">return s;</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">--测试 f_yearsal</span><br><span class="line">--存储函数在调用的时候,返回值需要接收</span><br><span class="line">declare </span><br><span class="line">s number(10);</span><br><span class="line">begin </span><br><span class="line">s := f_yearsal(7788);</span><br><span class="line">dbms_output.put_line(s);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>–out类型参数如何使用</p><p>–使用存储过程来算年薪</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CREATE </span><br><span class="line">OR REPLACE PROCEDURE p_yearsal ( eno emp.EMPNO % TYPE, yearsal OUT NUMBER )</span><br><span class="line">IS </span><br><span class="line">s NUMBER ( 10 );</span><br><span class="line">c EMP.COMM % TYPE;</span><br><span class="line">BEGIN</span><br><span class="line">SELECT</span><br><span class="line">sal * 12,</span><br><span class="line">nvl( comm, 0 ) INTO s,</span><br><span class="line">c </span><br><span class="line">FROM</span><br><span class="line">emp </span><br><span class="line">WHERE</span><br><span class="line">empno = eno;</span><br><span class="line">yearsal := s + c;</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">--测试p_yearsal</span><br><span class="line">DECLARE</span><br><span class="line">yearsal NUMBER ( 10 );</span><br><span class="line">BEGIN</span><br><span class="line">p_yearsal ( 7788, yearsal );</span><br><span class="line">dbms_output.put_line ( yearsal );</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><hr><h3 id="in和out类型参数的区别是什么"><a href="#in和out类型参数的区别是什么" class="headerlink" title="in和out类型参数的区别是什么?"></a>in和out类型参数的区别是什么?</h3><p>凡是涉及到into查询语句赋值或者:=赋值操作的参数,都必须使用out来修饰.</p><h3 id="存储过程和存储函数的区别"><a href="#存储过程和存储函数的区别" class="headerlink" title="存储过程和存储函数的区别"></a>存储过程和存储函数的区别</h3><p>语法上:关键字不一样,存储函数比存储过程多了两个return</p><p>本质上:存储函数有返回值,而存储过程没有返回值.</p><p>​        如果存储过程想实现有返回值的业务,这时我们需要使用out类型的参数</p><p>​        即使是存储过程使用了out类型的参数,其本质也不是真的有了返回值</p><p>​        而是在存储过程内部给给out类型参数赋值,在执行完毕后,我们直接拿到输出类型参数的值</p><hr><p>–我们可以使用存储函数有返回值的特性,来定义函数</p><p>–而存储过程不能来定义函数</p><p>–案例需求;查询出员工姓名.员工所在部门名称</p><p>–案例准备工作:把SCOTT用户下的dept表复制到当前用户下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">create table dept as select * from SCOTT.dept;</span><br><span class="line">--使用传统方式来实现案例需求</span><br><span class="line">select e.name ,d.name </span><br><span class="line">from emp e,dept d</span><br><span class="line">where e.deptno = d.deptno;</span><br><span class="line">--使用存储函数来实现提供一个部门编号,输出一个部门名称</span><br><span class="line">CREATE </span><br><span class="line">OR REPLACE FUNCTION fdna ( dno dept.DEPTNO % TYPE ) return dept.DNAME % TYPE </span><br><span class="line">IS </span><br><span class="line">dna dept.DNAME % TYPE;</span><br><span class="line">BEGIN</span><br><span class="line">SELECT</span><br><span class="line">DNAME INTO dna </span><br><span class="line">FROM</span><br><span class="line">dept </span><br><span class="line">WHERE</span><br><span class="line">deptno = dno;</span><br><span class="line">return dna;</span><br><span class="line">END;</span><br><span class="line">--使用fdna存储函数来实现案例需求,查询出员工姓名,员工所在部门名称.</span><br><span class="line">select e.ename, fdna(e.deptno)</span><br><span class="line">from emp e;</span><br></pre></td></tr></table></figure><p>–触发器,就是制定一个规则,在我们做增删改操作的时候,只要满足该规则,自动触发,无需调用,也不能调用</p><p>–触发器分语句级触发器和行级触发器</p><blockquote><p>语句级的触发器可以在某些语句执行前或执行后触发.不包含有for each row的触发器</p><p>行级触发器则是在定义了触发的表的行数据改变时就会被触发一次,包含有for each row</p><blockquote><p>for each row是为了使用:old或者:new对象或者一行记录.</p></blockquote></blockquote><h3 id="语句级触发器"><a href="#语句级触发器" class="headerlink" title="语句级触发器"></a>语句级触发器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--插入一条记录,输出一个新员工入职</span><br><span class="line">create or replace trigger t1</span><br><span class="line">after</span><br><span class="line">insert</span><br><span class="line">on person</span><br><span class="line">declare</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">  dbms_output.put_line(&apos;一个新员工入职&apos;);</span><br><span class="line">end;</span><br><span class="line">--触发t1</span><br><span class="line">insert into person values (1, &apos;小红&apos;);</span><br><span class="line">commit;</span><br><span class="line">[dbms导出:</span><br><span class="line">一个新员工入职]</span><br></pre></td></tr></table></figure><h3 id="行级别触发器"><a href="#行级别触发器" class="headerlink" title="行级别触发器"></a>行级别触发器</h3><p>–不能给员工降薪</p><p>–raise_application_error(-20001~-20999之间, ‘错误提示信息’);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">CREATE or REPLACE TRIGGER t2</span><br><span class="line">before</span><br><span class="line">update</span><br><span class="line">on emp</span><br><span class="line">for each row --行级</span><br><span class="line">DECLARE</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line">if :old.sal&gt;:new.sal then </span><br><span class="line">raise_application_error(-20001,&apos;不能给员工降薪&apos;);</span><br><span class="line">end if;</span><br><span class="line">end;</span><br><span class="line">--触发t2</span><br><span class="line">select * from emp where empno = 7788;</span><br><span class="line">update emp set sal =sal-1 where empno = 7788;</span><br><span class="line">commit;</span><br><span class="line">------------------------------</span><br><span class="line">信息:</span><br><span class="line">update emp set sal =sal-1 where empno = 7788</span><br><span class="line">&gt; ORA-20001: 不能给员工降薪</span><br><span class="line">  ORA-06512: at &quot;SCOTT.T2&quot;, line 5</span><br><span class="line">  ORA-04088: error during execution of trigger &apos;SCOTT.T2&apos;</span><br><span class="line">  </span><br><span class="line">&gt; 时间: 0.002s</span><br><span class="line">------------------------------</span><br></pre></td></tr></table></figure><p>–触发器实现主键自增.[行级触发器]</p><p>–分析:在用户做插入操作之前,拿到即将插入的数据,给该数据的主键列赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">create or replace trigger auid</span><br><span class="line">before</span><br><span class="line">insert</span><br><span class="line">on person</span><br><span class="line">for each row</span><br><span class="line">declare</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">  select s_person.nextval into :new.pid from dual;</span><br><span class="line">end;</span><br><span class="line">--查询person表数据</span><br><span class="line">select * from person;</span><br><span class="line">--使用auid实现主键自增</span><br><span class="line">insert into person (pname) values (&apos;a&apos;);</span><br><span class="line">commit;</span><br><span class="line">insert into person values (1, &apos;b&apos;);</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><hr><h4 id="如何在Navicat中查看触发器"><a href="#如何在Navicat中查看触发器" class="headerlink" title="如何在Navicat中查看触发器?"></a>如何在Navicat中查看触发器?</h4><p>一、选中指定的database，然后再依次选中“其它”、“触发器”</p><p>二、查看已写好的触发器语句 </p><p>​    选中触发器–&gt;DDL</p><p><img src="/images/oracle_02_01.png" alt="触发器"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;视图&quot;&gt;&lt;a href=&quot;#视图&quot; class=&quot;headerlink&quot; title=&quot;视图&quot;&gt;&lt;/a&gt;视图&lt;/h2&gt;&lt;p&gt;概念:视图就是提供一个查询的窗口,所有数据来自于原表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--查询语句创建表

create view v_emp
      
    
    </summary>
    
      <category term="数据库" scheme="https://fzqeven.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Oracle" scheme="https://fzqeven.top/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://fzqeven.top/2018/11/05/hello-world/"/>
    <id>https://fzqeven.top/2018/11/05/hello-world/</id>
    <published>2018-11-05T07:57:03.448Z</published>
    <updated>2018-11-08T02:50:11.233Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="测试分类" scheme="https://fzqeven.top/categories/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="测试标签" scheme="https://fzqeven.top/tags/%E6%B5%8B%E8%AF%95%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
</feed>
