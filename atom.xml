<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Even&amp;Fzq</title>
  
  <subtitle>月色三分</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fzqeven.top/"/>
  <updated>2019-01-06T13:55:49.699Z</updated>
  <id>https://fzqeven.top/</id>
  
  <author>
    <name>Even</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二  |使用docker搭建java环境|更改docker默认文件位置</title>
    <link href="https://fzqeven.top/2019/01/06/%E6%9C%8D%E5%8A%A1%E5%99%A8(2)/"/>
    <id>https://fzqeven.top/2019/01/06/服务器(2)/</id>
    <published>2019-01-06T11:54:52.536Z</published>
    <updated>2019-01-06T13:55:49.699Z</updated>
    
    <content type="html"><![CDATA[<p>折腾了一天,踩了巨多的坑,由于对Linux的挂载点不清楚,docker的相关文件存储位置也不知道,目录管理起来很麻烦,搜索了一些资料,下面将docker的默认位置从/usr/lib/docker移出去</p><h2 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h2><blockquote><p> 安装了xshell和xftp之后</p><p>使用docker来管理云简直太方便了,cool ~ ~</p><p>记录部分便于查阅</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> docker --help 查看docker帮助文档</span><br><span class="line"></span><br><span class="line"> systemctl start docker 启动docker</span><br><span class="line"> </span><br><span class="line"> systemctl stop docker  停止docker</span><br><span class="line"> </span><br><span class="line"> systemctl restart docker 重启docker</span><br><span class="line"> </span><br><span class="line"> systemctl enable docker 开机启动</span><br><span class="line"> ---------------------------------------------</span><br><span class="line"> docker ps 查看当前正在运行的容器</span><br><span class="line"></span><br><span class="line"> docker ps -a 查看所有容器的状态</span><br><span class="line"></span><br><span class="line"> docker start/stop id/name 启动/停止某个容器</span><br><span class="line"></span><br><span class="line"> docker attach id 进入某个容器(使用exit退出后容器也跟着停止运行)</span><br><span class="line"></span><br><span class="line"> docker exec -it 容器id（或者name） /bin/bash  启动一个伪终端以交互式的方式进入某个容器（使用exit退出后容器不停止运行）</span><br><span class="line"></span><br><span class="line"> docker images 查看本地镜像</span><br><span class="line"> docker rm id/name 删除某个容器</span><br><span class="line"> docker rmi id/name 删除某个镜像</span><br><span class="line">---------------------</span><br><span class="line">以上命令已经够用了,</span><br><span class="line">更多详细的学习,学习参考:</span><br><span class="line">https://yeasy.gitbooks.io/docker_practice/</span><br></pre></td></tr></table></figure><p>搭配daocloud图形化界面使用,连接上服务器直接操作docker的容器和镜像</p><p><a href="https://dashboard.daocloud.io" target="_blank" rel="noopener">https://dashboard.daocloud.io</a></p><h2 id="更改docker默认文件位置"><a href="#更改docker默认文件位置" class="headerlink" title="更改docker默认文件位置"></a>更改docker默认文件位置</h2><p>在/home 目录下创建目录.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home</span><br><span class="line">mkdir docker</span><br></pre></td></tr></table></figure><p>修改docker的systemd的 docker.service的配置文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure><p>在里面的EXECStart的后面增加后如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd --graph /home/docker</span><br></pre></td></tr></table></figure><p>修改前:</p><p><img src="/images/fuwuqidajian/fuwu21.png" alt="img"> </p><p>修改后:</p><p><img src="/images/fuwuqidajian/fuwu22.png" alt="img"> </p><p>如果docker是1.12或以上的版本，可以修改（或新建）daemon.json文件。修改后会立即生效，不需重启docker服务。</p><p> <strong>vim /etc/docker/daemon.json</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line"> &quot;registry-mirrors&quot;: [&quot;http://7e61f7f9.m.daocloud.io&quot;],&quot;graph&quot;: &quot;/home/docker&quot;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p> 资料链接,我使用的是方法2,有效      <a href="http://blog.51cto.com/12447922/2059793" target="_blank" rel="noopener">http://blog.51cto.com/12447922/2059793</a></p></blockquote><p>修改了之后使用docker info 查看一下是否修改成功</p><p><img src="/images/fuwuqidajian/1546764768795.png" alt="1546764768795"></p><p>用了一天的时间学习了docker详细指南和基本操作命令和反反复复踩了很多的坑,下面开始来配置javaweb环境.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;折腾了一天,踩了巨多的坑,由于对Linux的挂载点不清楚,docker的相关文件存储位置也不知道,目录管理起来很麻烦,搜索了一些资料,下面将docker的默认位置从/usr/lib/docker移出去&lt;/p&gt;
&lt;h2 id=&quot;docker常用命令&quot;&gt;&lt;a href=&quot;#do
      
    
    </summary>
    
      <category term="阿里云服务器" scheme="https://fzqeven.top/categories/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Linux" scheme="https://fzqeven.top/tags/Linux/"/>
    
      <category term="xshell/xftp" scheme="https://fzqeven.top/tags/xshell-xftp/"/>
    
      <category term="docker" scheme="https://fzqeven.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>一  |阿里云Linux服务器初建(工具:Xshell/xftp)</title>
    <link href="https://fzqeven.top/2019/01/06/%E6%9C%8D%E5%8A%A1%E5%99%A8(1)/"/>
    <id>https://fzqeven.top/2019/01/06/服务器(1)/</id>
    <published>2019-01-06T11:54:52.363Z</published>
    <updated>2019-01-06T13:55:39.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><blockquote><p>SSH:Secure Shell的缩写,安全外壳协议,是建立在应用层基础上的安全协议.是目前较为可靠,专为远程登录会话和其他网络服务提供安全性的协议.利用ssh协议可以有效防止远程管理过程中的信息泄漏问题.<br>Xshell   是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。Xshell 通过互联网到远程主机的安全连接以及它创新性的设计和特色帮助用户在复杂的网络环境中享受他们的工作。</p></blockquote><p>emmmm………</p><p>xshell和xftp界面好看,操作简单人性化,相比其他远程工具,这两个使用感受敲棒的~</p><h2 id="linux常用指令"><a href="#linux常用指令" class="headerlink" title="linux常用指令"></a>linux常用指令</h2><h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><blockquote><p>记录部分便于查阅</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd /home 进入目录</span><br><span class="line">cd .. 返回上一级目录</span><br><span class="line">cd ../.. 返回上两级目录</span><br><span class="line">cd 进入个人的主目录</span><br><span class="line">cd - 返回上次所在的目录</span><br><span class="line">pwd 显示工作路径</span><br><span class="line">ls 查看目录中的文件</span><br><span class="line">ll 查看目录中的文件(显示文件中的内容)</span><br><span class="line">ll -f 显示隐藏文件</span><br><span class="line">ll -a 显现隐藏文件(包括文件中的内容)</span><br></pre></td></tr></table></figure><p>Linux命令:</p><p><a href="https://www.cnblogs.com/yjd_hycf_space/p/7730690.html" target="_blank" rel="noopener">https://www.cnblogs.com/yjd_hycf_space/p/7730690.html</a></p><h2 id="服务器初建"><a href="#服务器初建" class="headerlink" title="服务器初建"></a>服务器初建</h2><ol><li><p>下载及安装Xshell和Xftp.</p><p>新手教程<img src="/images/0EABD8B4.png" alt="img"> :</p></li></ol><p><a href="https://blog.csdn.net/weixin_40928253/article/details/80621724" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40928253/article/details/80621724</a></p><p><a href="https://jingyan.baidu.com/article/ad310e800eec371848f49e52.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/ad310e800eec371848f49e52.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SSH&quot;&gt;&lt;a href=&quot;#SSH&quot; class=&quot;headerlink&quot; title=&quot;SSH&quot;&gt;&lt;/a&gt;SSH&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;SSH:Secure Shell的缩写,安全外壳协议,是建立在应用层基础上的安全协议.是目前较为可靠,专为
      
    
    </summary>
    
      <category term="阿里云服务器" scheme="https://fzqeven.top/categories/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Linux" scheme="https://fzqeven.top/tags/Linux/"/>
    
      <category term="xshell/xftp" scheme="https://fzqeven.top/tags/xshell-xftp/"/>
    
  </entry>
  
  <entry>
    <title>三  |使用docker搭建java环境|mysql|Tomcat</title>
    <link href="https://fzqeven.top/2019/01/06/%E6%9C%8D%E5%8A%A1%E5%99%A8(3)/"/>
    <id>https://fzqeven.top/2019/01/06/服务器(3)/</id>
    <published>2019-01-06T11:54:52.361Z</published>
    <updated>2019-01-06T13:55:59.303Z</updated>
    
    <content type="html"><![CDATA[<p>1）yum 包更新到最新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure><p>（2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>（3）设置yum源为阿里云</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>（4）安装docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure><p>（5）安装后查看docker版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><p>  (6)  启动docker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>  (7)  开机启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p>设置国内的镜像,这里的daemon.json,没有这个文件要先创建.json文件</p><p><a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker" target="_blank" rel="noopener">https://lug.ustc.edu.cn/wiki/mirrors/help/docker</a></p><p>编辑该文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>在该文件中输入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里我将docker默认目录放在了/home/docker下,更改了默认目录还要加默认目录的位置</span><br><span class="line">//参见  搭建(二)</span><br></pre></td></tr></table></figure><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p>(查找Docker Hub上的mysql镜像,会列出各种镜像,选择自己想要的) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure><p>(拉取mysql 5.6版本的镜像,为什么不选择最新版本,因为5.7版本以后会需要设置认证,一般人不会去设置,会在连接的时候报一个错误,为了不必要的麻烦,我选择5.6版本)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.6</span><br></pre></td></tr></table></figure><p>启动MySQL镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=mysql -itd -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root mysql</span><br></pre></td></tr></table></figure><p>进入MySQL容器</p><p>运行  docker exec -it mysql /bin/bash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure><p>进入MySQL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行  mysql -uroot -p</span><br></pre></td></tr></table></figure></p><p>由于mysql中root执行绑定在了<code>localhost</code>，因此需要对root进行授权，代码如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;root&apos; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><p>截图如下:</p><p><img src="/images/fuwuqidajian/1546774751282.png" alt="1546774751282"></p><p>这时,使用Navicat连接3306端口,主机选择阿里云服务器的ip就可以连接了.</p><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><p>1.安装tomcat</p><p>与安装mysql类似，运行如下命令</p><p>docker pull tomcat<br>2.运行tomcat</p><p>docker run –name tomcat -p 8080:8080 -v $PWD/tomcat:/usr/local/tomcat/webapps -d tomcat  </p><p>参数说明：</p><p>-p 8080:8080：将容器的8080端口映射到主机的8080端口</p><p>-v $PWD/tomcat:/usr/local/tomcat/webapps：将主机中当前目录下的tomcat挂载到容器的/webapps</p><p>另外，tomcat的官方镜像中已经自带了jdk的环境，所以就不用特地去配置jdk的环境了。</p><h2 id="配置阿里云安全组规则-很重要"><a href="#配置阿里云安全组规则-很重要" class="headerlink" title="配置阿里云安全组规则|很重要!"></a>配置阿里云安全组规则|很重要!</h2><p>使用阿里云服务器还需要到阿里云控制台配置实例的安全组规则，否则无法从远端访问服务器,<br>官方提供了http80端口,mysql3306端口等常用端口。配置好了就可以在浏览器访问测试了!</p><h2 id="配置成功"><a href="#配置成功" class="headerlink" title="配置成功"></a>配置成功</h2><p><img src="/images/fuwuqidajian/1546775281397.png" alt="1546775281397"></p><p><img src="/images/fuwuqidajian/1546775314617.png" alt="1546775314617"></p><h2 id="喜大普奔"><a href="#喜大普奔" class="headerlink" title="喜大普奔!!"></a>喜大普奔!!</h2><p>踩了好多好多好多坑,闷头搞了一天,可以开始愉快的玩耍啦!!!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1）yum 包更新到最新&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="阿里云服务器" scheme="https://fzqeven.top/categories/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Linux" scheme="https://fzqeven.top/tags/Linux/"/>
    
      <category term="docker" scheme="https://fzqeven.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习(一)_六大原则</title>
    <link href="https://fzqeven.top/2018/11/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>https://fzqeven.top/2018/11/24/设计模式的六大原则/</id>
    <published>2018-11-24T02:09:56.525Z</published>
    <updated>2018-12-18T06:09:31.526Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h2><blockquote><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p></blockquote><p>设计模式主要是基于以下面向对象设计原则</p><ul><li>对接口编程而不是对实现编程</li><li>优先使用对象组合而不是继承</li></ul><h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><p>考软考的时候强行背下来,但是理解不深刻,索性还是自己整理学习一遍.23种设计模式则是遵循了这六大原则,达到了<strong>高内聚,低耦合</strong>,使程序<strong>可维护,可复用,可拓展</strong></p><h3 id="总原则、开闭原则（Open-Close-Principle）"><a href="#总原则、开闭原则（Open-Close-Principle）" class="headerlink" title="总原则、开闭原则（Open Close Principle）"></a><strong>总原则、开闭原则（Open Close Principle）</strong></h3><p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。</p><p><strong>[尽量不要更改源代码,而是在原有的基础上增加新的类—用抽象实现框架,用实现扩展细节]</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例:</span><br><span class="line">版本更新：尽量不更改源代码，可以增加新功能</span><br><span class="line"></span><br><span class="line">员工迟到问题：可以制定迟到的晚下班，迟到多久就得加班多久等制度</span><br><span class="line"></span><br><span class="line">即：上班总时长封闭，对于迟到一点开放</span><br></pre></td></tr></table></figure><p>在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。开闭原则具有理想主义色彩,想要达到这样的效果，我们需要使用接口和抽象类，在学习和理解设计模式的时候,则会更好更深刻的体会到这几个原则。</p><p>(菜鸟教程里把这一条替换了单一职责原则,而菜鸟付紫琴还Google了一下为什么菜鸟教程里面没有写单一职责原则….于是强行加进来,强行理解一下)</p><p>以下六条原则则是开闭原则的实现方法</p><h3 id="1、单一职责原则（Single-responsibility-principle）"><a href="#1、单一职责原则（Single-responsibility-principle）" class="headerlink" title="1、单一职责原则（Single responsibility principle）"></a><strong>1、单一职责原则</strong>（Single responsibility principle）</h3><p>又称单一功能原则,<strong>一个类应该只有一个发生变化的原因</strong>.每一个职责都是变化的一个轴线，如果一个类有一个以上的职责，这些职责就耦合在了一起。这会导致脆弱的设计。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响[复用性.例如：要实现逻辑和界面的分离。[高内聚,低耦合]</p><h3 id="2、里氏代换原则（Liskov-Substitution-Principle）"><a href="#2、里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="2、里氏代换原则（Liskov Substitution Principle）"></a><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></h3><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，<strong>任何基类可以出现的地方，子类一定可以出现</strong>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我的理解:</span><br><span class="line"></span><br><span class="line">- 扩展功能(例如update)时继承父类,尽量不要覆盖重写,</span><br><span class="line">- 重载父类的方法时,前置条件(即形参)要比父类的输入参数更宽松.</span><br><span class="line">- 实现抽象方法时,方法的后置条件(即返回值)要更严格.</span><br><span class="line"></span><br><span class="line">  否则会使原有功能发生故障</span><br></pre></td></tr></table></figure><p>设计模式中比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替.</p><p><strong>LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的特有的行为</strong>。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><h3 id="3、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#3、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="3、依赖倒转原则（Dependence Inversion Principle）"></a><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></h3><p><strong>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</strong></p><p>这个原则是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如:</span><br><span class="line">类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</span><br><span class="line"></span><br><span class="line">解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。</span><br></pre></td></tr></table></figure><h3 id="4、接口隔离原则（Interface-Segregation-Principle）"><a href="#4、接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="4、接口隔离原则（Interface Segregation Principle）"></a><strong>4、接口隔离原则（Interface Segregation Principle）</strong></h3><p>这个原则的意思是：<strong>类依赖于最小接口,否则实现了不需要的方法,耦合度也增高.使用多个隔离的接口，比使用单个接口要好</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如:</span><br><span class="line">客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 </span><br><span class="line">问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。</span><br><span class="line"></span><br><span class="line">解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</span><br></pre></td></tr></table></figure><p>它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><h3 id="5、迪米特法则，又称最少知道原则（Demeter-Principle）"><a href="#5、迪米特法则，又称最少知道原则（Demeter-Principle）" class="headerlink" title="5、迪米特法则，又称最少知道原则（Demeter Principle）"></a><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></h3><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。<strong>一个类对他所依赖的类知道的越少越好</strong></p><blockquote><p>[今天用到activeMQ时,突然理解了这个法则的应用场景,屁颠屁颠的来更新这篇笔记]<br>[这种知识突然连成一片儿的感觉超级nice啊哈哈哈]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">由于狭义迪米特法则要求两个类不必直接通信时,进行的方法调用应当由第三个类来转发调用.这样在系统中制造出大量的小方法,从而使系统显得凌乱.</span><br><span class="line">其可以使局部的模块得到简化,但是也会造成模块间的通信效率降低,使模块间不容易协调.</span><br><span class="line"></span><br><span class="line">但是迪米特法则讨论的是对象之间信息的流量,方向以及信息影响的控制.主要的意图是控制信息过载.要求一个模块应当尽可能的将自己的内部数据和实现细节隐藏起来,也就是要求有良好的封装性.</span><br><span class="line"></span><br><span class="line">另以今天理解JMS和activeMQ为例,JMS是消息服务的一组规范和接口,activeMQ则是JMS的实现.</span><br><span class="line">服务层和web层交互,模块间的依赖则存在一系列耦合关系.耦合越多,后期的维护工作则越难.改善模块间的调用关系.则应用到了消息中介,模块与模块之间互相不认识.消息的发送者和接收者互不影响,实现过程都被封装了.</span><br><span class="line">即回到六字箴言--&quot;高内聚,低耦合&quot;.</span><br></pre></td></tr></table></figure><blockquote><p>设计模式的门面模式(Facade) 和中介模式(Mediator),都是迪米特法则的应用.</p><p>啊哈,这两个模式还没有学习到,安排上了~</p></blockquote><p>迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。</p><h3 id="6、合成复用原则（Composite-Reuse-Principle）"><a href="#6、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6、合成复用原则（Composite Reuse Principle）"></a><strong>6、合成复用原则（Composite Reuse Principle）</strong></h3><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p><h2 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h2><p>根据设计模式的参考书 <strong>Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong> 中所提到的，总共有 23 种设计模式。</p><p>这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。</p><p>当然，我们还会讨论另一类设计模式：J2EE 设计模式。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">模式 &amp; 描述</th><th style="text-align:left">包括</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left"><strong>创建型模式</strong> <br>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</td><td style="text-align:left">工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left"><strong>结构型模式</strong><br> 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td style="text-align:left">适配器模式（Adapter Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left"><strong>行为型模式</strong> <br>这些设计模式特别关注对象之间的通信。</td><td style="text-align:left">责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left"><strong>J2EE 模式</strong> <br>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</td><td style="text-align:left">MVC 模式（MVC Pattern）<br>业务代表模式（Business Delegate Pattern）<br>组合实体模式（Composite Entity Pattern）<br>数据访问对象模式（Data Access Object Pattern）<br>前端控制器模式（Front Controller Pattern）<br>拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）<br>传输对象模式（Transfer Object Pattern）</td></tr></tbody></table><p>设计模式之间的关系</p><p><img src="http://www.runoob.com/wp-content/uploads/2014/08/the-relationship-between-design-patterns.jpg" alt="菜鸟教程_设计模式之间的关系"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;设计模式简介&quot;&gt;&lt;a href=&quot;#设计模式简介&quot; class=&quot;headerlink&quot; title=&quot;设计模式简介&quot;&gt;&lt;/a&gt;设计模式简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;设计模式是一套被反复使用的、多数人知晓的、经过分类编目的
      
    
    </summary>
    
      <category term="设计模式" scheme="https://fzqeven.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://fzqeven.top/tags/Java/"/>
    
      <category term="设计模式六大原则" scheme="https://fzqeven.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
      <category term="设计模式的三种类型+J2EE模式" scheme="https://fzqeven.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B-J2EE%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>idea调试功能</title>
    <link href="https://fzqeven.top/2018/11/22/idea%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD/"/>
    <id>https://fzqeven.top/2018/11/22/idea调试功能/</id>
    <published>2018-11-21T18:02:36.602Z</published>
    <updated>2018-11-23T02:28:04.020Z</updated>
    
    <content type="html"><![CDATA[<p>今天bug太多,要气死喵了,气到不想敲码,整理整理debug功能的使用,bug真是让人头秃,叉会儿腰!</p><h3 id="bug使我强-头-大-秃-debug功能"><a href="#bug使我强-头-大-秃-debug功能" class="headerlink" title="bug使我强(头)大(秃)!_debug功能"></a>bug使我强(头)大(秃)!_debug功能</h3><p>1.心平气和改bug!</p><p>2.扎实基础!(flag)</p><p>3.代码规范</p><p><img src="/images/idea调试.jpg" alt=""></p><h2 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h2><p><img src="/images/idea调试_01.png" alt="1542801420385"></p><h2 id="开启调试会话"><a href="#开启调试会话" class="headerlink" title="开启调试会话"></a>开启调试会话</h2><p>这只冒着绿光的小虫子</p><p><img src="/images/idea调试_02.png" alt="img"></p><p><img src="/images/idea调试_03.png" alt="1542803118466"></p><h2 id="单步调试"><a href="#单步调试" class="headerlink" title="单步调试"></a>单步调试</h2><ul><li><p>step over</p><p>程序向下执行一行(如果当前行有方法调用,这个方法将被执行完)</p></li><li><p>step into</p><p>如果该行有自定义的方法,则会进入自定义的方法(不会进入官方类库的方法)</p></li><li><p>force step into</p><p>该按钮在调试的时候能进入任何方法</p></li><li><p>step out</p><p>如果在调试的时候进入一个方法,并觉得没有问题,可以跳出该方法.</p><p>(之前笨的要死,一直step over到下一行)</p></li><li><p>drop frame</p><p>这个按钮返回到当前方法的调用处重新执行,并且上下文有关变量也会回到那个时候,只要调用链中还有上级方法,可以跳到任何一个方法</p></li></ul><p><img src="/images/idea调试_04.png" alt=""></p><h2 id="跨断点调试"><a href="#跨断点调试" class="headerlink" title="跨断点调试"></a>跨断点调试</h2><p>程序运行到下一个断点处,后面没有断点,则执行完程序</p><p><img src="/images/idea调试_05.png" alt="1542821550967"></p><h2 id="查看断点"><a href="#查看断点" class="headerlink" title="查看断点"></a>查看断点</h2><p>可以查看设置过的断点,设置断点的一些属性</p><p>可以设置条件断点（满足某个条件的时候，暂停程序的执行，如 c==97）。结束调试后，把所设的断点删除(选择要删除的断点后，点击上方的红色减号）</p><p><img src="/images/idea调试_06.png" alt="1542821976708"></p><h2 id="设置变量值"><a href="#设置变量值" class="headerlink" title="设置变量值"></a>设置变量值</h2><p>选中变量,右键setValue可以设置变量值.</p><p>(迷迷糊糊把idea关了,懒开了,睡吧睡吧付紫琴,晚安啦,明天再寻思寻思怎么高效的debug)</p><p><img src="/images/idea调试_07.png" alt="1542822584146"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天bug太多,要气死喵了,气到不想敲码,整理整理debug功能的使用,bug真是让人头秃,叉会儿腰!&lt;/p&gt;
&lt;h3 id=&quot;bug使我强-头-大-秃-debug功能&quot;&gt;&lt;a href=&quot;#bug使我强-头-大-秃-debug功能&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="这是一只小猫咪" scheme="https://fzqeven.top/categories/%E8%BF%99%E6%98%AF%E4%B8%80%E5%8F%AA%E5%B0%8F%E7%8C%AB%E5%92%AA/"/>
    
    
      <category term="Java" scheme="https://fzqeven.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习之策略模式 strategy pattern!</title>
    <link href="https://fzqeven.top/2018/11/17/strategy-pattern/"/>
    <id>https://fzqeven.top/2018/11/17/strategy-pattern/</id>
    <published>2018-11-16T18:05:19.000Z</published>
    <updated>2018-11-24T01:55:26.430Z</updated>
    
    <content type="html"><![CDATA[<p>面对这些有类似的属性但不同的行为的类来说，使用策略模式便有利于类的拓展，其原则是：多用组合，少用继承。</p><h2 id="图片图片图片图片没有没有没有显示显示显示显示显示"><a href="#图片图片图片图片没有没有没有显示显示显示显示显示" class="headerlink" title="图片图片图片图片没有没有没有显示显示显示显示显示"></a>图片图片图片图片没有没有没有显示显示显示显示显示</h2><h2 id="不困不困不困不困不困怎么办"><a href="#不困不困不困不困不困怎么办" class="headerlink" title="不困不困不困不困不困怎么办"></a>不困不困不困不困不困怎么办</h2><h2 id="上次上次上次都可以显示-为什么这次不显示不显示不显示"><a href="#上次上次上次都可以显示-为什么这次不显示不显示不显示" class="headerlink" title="上次上次上次都可以显示,为什么这次不显示不显示不显示"></a>上次上次上次都可以显示,为什么这次不显示不显示不显示</h2><h2 id="睡觉-晚安"><a href="#睡觉-晚安" class="headerlink" title="睡觉,晚安!"></a>睡觉,晚安!</h2><p><img src="/images/strategyPattern.png" alt="策略模式"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面对这些有类似的属性但不同的行为的类来说，使用策略模式便有利于类的拓展，其原则是：多用组合，少用继承。&lt;/p&gt;
&lt;h2 id=&quot;图片图片图片图片没有没有没有显示显示显示显示显示&quot;&gt;&lt;a href=&quot;#图片图片图片图片没有没有没有显示显示显示显示显示&quot; class=&quot;head
      
    
    </summary>
    
      <category term="设计模式" scheme="https://fzqeven.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://fzqeven.top/tags/Java/"/>
    
      <category term="设计模式" scheme="https://fzqeven.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="策略模式" scheme="https://fzqeven.top/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Oracle学习_01</title>
    <link href="https://fzqeven.top/2018/11/13/Oracle%E5%AD%A6%E4%B9%A0_01/"/>
    <id>https://fzqeven.top/2018/11/13/Oracle学习_01/</id>
    <published>2018-11-13T08:52:03.440Z</published>
    <updated>2018-11-16T18:00:54.013Z</updated>
    
    <content type="html"><![CDATA[<h4 id="创建表空间"><a href="#创建表空间" class="headerlink" title="创建表空间"></a>创建表空间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE tablespace fuziqin</span><br><span class="line">datafile &apos;c:\fuziqin.dbf&apos;</span><br><span class="line">size 100m</span><br><span class="line">autoextend on</span><br><span class="line">next 10m;</span><br></pre></td></tr></table></figure><h4 id="删除表空间"><a href="#删除表空间" class="headerlink" title="删除表空间"></a>删除表空间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop tablespace fuziqin</span><br></pre></td></tr></table></figure><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create user fuziqin</span><br><span class="line">identified by fuziqin</span><br><span class="line">default tablespace fuziqin</span><br></pre></td></tr></table></figure><h4 id="给用户授权"><a href="#给用户授权" class="headerlink" title="给用户授权"></a>给用户授权</h4><p>–oracle数据库中常用角色<br>connect–连接角色，基本角色<br>resource–开发者角色<br>dba–超级管理员角色</p><p>–给fuziqin授予dba角色<br><code>grant dba to fuziqin;</code></p><p>–切换到fuziiqn用户下,创建一个person表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table person(</span><br><span class="line">       pid number(20),</span><br><span class="line">       pname varchar2(10)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--添加一列</span><br><span class="line">alter table person add (gender number(1));</span><br><span class="line">--修改列类型</span><br><span class="line">alter table person modify gender char(1);</span><br><span class="line">--修改列名称</span><br><span class="line">alter table person rename column gender to sex;</span><br><span class="line">--删除一列</span><br><span class="line">alter table person drop column sex;</span><br></pre></td></tr></table></figure><h4 id="查询表中记录"><a href="#查询表中记录" class="headerlink" title="查询表中记录"></a>查询表中记录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select * from person</span><br><span class="line">--添加一条记录</span><br><span class="line">insert into person (pid,pname) values </span><br><span class="line">commit;</span><br><span class="line">--修改一条记录</span><br><span class="line">update person set pname = &apos;王昱珩&apos; where pid = 1;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><h4 id="三个删除"><a href="#三个删除" class="headerlink" title="三个删除"></a>三个删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--删除表中全部记录</span><br><span class="line">delete from person;</span><br><span class="line">--删除表结构</span><br><span class="line">drop table person;</span><br><span class="line">--先删除表，再次创建表。效果等同于删除表中全部记录。</span><br><span class="line">--在数据量大的情况下，尤其在表中带有索引的情况下，该操作效率高。</span><br><span class="line">--索引可以提供查询效率，但是会影响增删改效率。</span><br><span class="line">truncate table person;</span><br></pre></td></tr></table></figure><hr><h4 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h4><p>序列不真的属于任何一张表,但是可以逻辑和表做绑定</p><p>序列:默认从1开始,依次递增,主要用来给主键赋值使用</p><p>dual:虚表,只是为了补全语法,没有任何意义</p><blockquote><p>创建序列<br>​    语法 CREATE SEQUENCE 序列名 [相关参数]<br>参数说明<br>​    INCREMENT BY :序列变化的步进，负值表示递减。(默认1)<br>​    START WITH:序列的初始值 。(默认1)<br>​    MAXvalue:序列可生成的最大值。(默认不限制最大值，NOMAXVALUE)<br>​    MINVALUE:序列可生成的最小值。(默认不限制最小值，NOMINVALUE)<br>​    CYCLE:用于定义当序列产生的值达到限制值后是否循环(NOCYCLE:不循环，CYCLE:循环)。<br>​    CACHE:表示缓存序列的个数，数据库异常终止可能会导致序列中断不连续的情况，默认值为20，如果不使用缓存可设置NOCACHE<br>例<br>​    CREATE SEQUENCE SEQ_DEMO<br>​    INCREMENT BY 1<br>​    START WITH 1<br>​    NOMAXvalue<br>​    NOCYCLE<br>​    NOCACHE;</p></blockquote><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">create sequence s_person;</span><br><span class="line"></span><br><span class="line">--nextval :取得序列的下一个内容</span><br><span class="line">--currval :取得序列的当前内容</span><br><span class="line">select s_person.nextval from dual;</span><br><span class="line">select s_person.currval from dual;</span><br><span class="line"></span><br><span class="line">insert into person (pid ,pname) values (s_person.nextval,&apos;华晨宇&apos;);</span><br><span class="line">commit;</span><br><span class="line">SELECT * from person;</span><br><span class="line"></span><br><span class="line">nextval :取得序列的下一个内容</span><br><span class="line">currval :取得序列的当前内容</span><br><span class="line">select seqpersonid.nextval from dual;</span><br><span class="line">select s_person.currval from dual;</span><br></pre></td></tr></table></figure><h4 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--解锁scott用户，密码tiger</span><br><span class="line">alter user scott account unlock;</span><br><span class="line">--解锁scott用户的密码【此句也可以用来重置密码】</span><br><span class="line">alter user scott identified by tiger;</span><br></pre></td></tr></table></figure><h4 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h4><p>作用于一行,返回一个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--字符函数</span><br><span class="line">select upper(&apos;yes&apos;) from dual;--YES</span><br><span class="line">select lower(&apos;YES&apos;) from dual;--yes</span><br><span class="line">--数值函数</span><br><span class="line">select round(56.16, -2) from dual;---四舍五入，后面的参数表示保留的位数</span><br><span class="line">select trunc(56.16, -1) from dual;---直接截取，不在看后面位数的数字是否大于5.</span><br><span class="line">select mod(10, 3) from dual;---求余数</span><br></pre></td></tr></table></figure><h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--查询出emp表中所有员工入职距离现在几天。</span><br><span class="line">select sysdate-e.hiredate from emp e;</span><br><span class="line">--算出明天此刻</span><br><span class="line">select sysdate+1 from dual;</span><br><span class="line">--查询出emp表中所有员工入职距离现在几月。</span><br><span class="line">select months_between(sysdate,e.hiredate) from emp e;</span><br><span class="line">--查询出emp表中所有员工入职距离现在几年。</span><br><span class="line">select months_between(sysdate,e.hiredate)/12 from emp e;</span><br><span class="line">--查询出emp表中所有员工入职距离现在几周。</span><br><span class="line">select round((sysdate-e.hiredate)/7) from emp e;</span><br></pre></td></tr></table></figure><h4 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h4><blockquote><p>to_date(“要转换的字符串”,”转换的格式”)   两个参数的格式必须匹配，否则会报错。</p><p>即按照第二个参数的格式解释第一个参数。</p><p>to_char(日期,”转换格式” ) 即把给定的日期按照“转换格式”转换。</p><p>转换的格式：</p><p>表示year的：y  表示年的最后一位 yy 表示年的最后2位 yyy 表示年的最后3位 yyyy 用4位数表示年</p><p>表示month的：mm 用2位数字表示月；mon 用简写形式 比如11月或者nov ；month 用全称 比如11月或者november</p><p>表示day的：dd 表示当月第几天；ddd表示当年第几天；dy 当周第几天 简写  比如星期五或者fri；day当周第几天 全写</p><p>比如星期五或者friday。</p><p>表示hour的：hh 2位数表示小时 12进制； hh24 2位数表示小时 24小时</p><p>表示minute的：mi 2位数表示分钟</p><p>表示second的：ss 2位数表示秒 60进制</p><p>表示季度的：q 一位数 表示季度 （1-4）</p><p>另外还有ww 用来表示当年第几周 w用来表示当月第几周。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--日期转字符串</span><br><span class="line">select to_char(sysdate, &apos;fm yyyy-mm-dd hh24:mi:ss&apos;) from dual;</span><br><span class="line">--字符串转日期</span><br><span class="line">select to_date(&apos;2018-6-7 16:39:50&apos;, &apos;fm yyyy-mm-dd hh24:mi:ss&apos;) from dual;</span><br></pre></td></tr></table></figure><h4 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--算出emp表中所有员工的年薪</span><br><span class="line">--奖金里面有null值，如果null值和任意数字做算术运算，结果都是null。</span><br><span class="line">select e.sal*12+nvl(e.comm, 0) from emp e;</span><br></pre></td></tr></table></figure><h4 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h4><p>mysql和Oracle通用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">--给emp表员工取中文名</span><br><span class="line"></span><br><span class="line">select e.ename, </span><br><span class="line">       case e.ename</span><br><span class="line">         when &apos;SMITH&apos; then &apos;华晨宇&apos;</span><br><span class="line">           when &apos;ALLEN&apos; then &apos;王昱珩&apos;</span><br><span class="line">             when &apos;WARD&apos; then &apos;李健&apos;</span><br><span class="line">               --else &apos;付紫琴&apos;</span><br><span class="line">                 end</span><br><span class="line">from emp e;</span><br><span class="line"></span><br><span class="line">--判断emp表中员工工资，如果高于3000显示高收入，如果高于1500低于3000显示中等收入，</span><br><span class="line">--其余显示低收入</span><br><span class="line">select e.sal, </span><br><span class="line">       case </span><br><span class="line">         when e.sal&gt;3000 then &apos;高收入&apos;</span><br><span class="line">           when e.sal&gt;1500 then &apos;中等收入&apos;</span><br><span class="line">               else &apos;低收入&apos;</span><br><span class="line">                 end</span><br><span class="line">from emp e;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p> oracle中除了起别名，都用单引号。</p></blockquote></blockquote><p>oracle专用条件表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select e.ename, </span><br><span class="line">        decode(e.ename,</span><br><span class="line">          &apos;SMITH&apos;,  &apos;华晨宇&apos;,</span><br><span class="line">            &apos;ALLEN&apos;,  &apos;王昱珩&apos;,</span><br><span class="line">              &apos;WARD&apos;,  &apos;李健&apos;,</span><br><span class="line">                &apos;喵&apos;) &quot;中文名&quot;             </span><br><span class="line">from emp e;</span><br></pre></td></tr></table></figure><h4 id="多行函数"><a href="#多行函数" class="headerlink" title="多行函数"></a>多行函数</h4><p>【聚合函数】：作用于多行，返回一个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select count(1) from emp;---查询总数量</span><br><span class="line">select sum(sal) from emp;---工资总和</span><br><span class="line">select max(sal) from emp;---最大工资</span><br><span class="line">select min(sal) from emp;---最低工资</span><br><span class="line">select avg(sal) from emp;---平均工资</span><br></pre></td></tr></table></figure><h4 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h4><p>–查询出每个部门的平均工资<br>–分组查询中,出现group by后面的原始列,才能出现在select后面<br>–没有出现在group by后面的列,想在select后面,必须加上聚合函数<br>–聚合函数有一个特性,可以把多行记录变成一个值.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">e.deptno,</span><br><span class="line">avg( e.sal ) </span><br><span class="line">FROM</span><br><span class="line">emp e </span><br><span class="line">GROUP BY</span><br><span class="line">e.deptno;</span><br></pre></td></tr></table></figure><p>–查出平均工资高于2000的部门信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">e.DEPTNO,</span><br><span class="line">avg( e.sal ) asal </span><br><span class="line">FROM</span><br><span class="line">emp e </span><br><span class="line">GROUP BY e.DEPTNO</span><br><span class="line">having avg(e.sal)&gt;2000;</span><br></pre></td></tr></table></figure><p>–所有条件都不能使用别名来判断.</p><p>例:select ename ,sal s from emp where sal&gt;1500;</p><p>–查询出每个部门工资高于800的员工的平均工资</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">e.DEPTNO,</span><br><span class="line">avg( e.sal ) asal </span><br><span class="line">FROM</span><br><span class="line">emp e </span><br><span class="line">WHERE</span><br><span class="line">e.sal &gt; 800 </span><br><span class="line">GROUP BY</span><br><span class="line">e.DEPTNO;</span><br></pre></td></tr></table></figure><hr><p>where是过滤分组前的数据,having是过滤分组后的数据.where必须在group by之前,having是在group by 之后.</p><hr><p>查询出每个部门高出800工资的员工的平均工资,然后再查出平均工资高于2000的部门</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">e.DEPTNO,</span><br><span class="line">avg( e.sal ) asal </span><br><span class="line">FROM</span><br><span class="line">emp e </span><br><span class="line">WHERE</span><br><span class="line">e.sal &gt; 800 </span><br><span class="line">GROUP BY</span><br><span class="line">e.DEPTNO </span><br><span class="line">HAVING</span><br><span class="line">avg( e.SAL ) &gt; 2000;</span><br></pre></td></tr></table></figure><h4 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h4><h5 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">* </span><br><span class="line">FROM</span><br><span class="line">emp e,</span><br><span class="line">dept d ;</span><br></pre></td></tr></table></figure><h5 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">* </span><br><span class="line">FROM</span><br><span class="line">emp e,</span><br><span class="line">dept d </span><br><span class="line">WHERE</span><br><span class="line">e.deptno = d.deptno;</span><br></pre></td></tr></table></figure><h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">* </span><br><span class="line">FROM</span><br><span class="line">emp e,</span><br><span class="line">dept d </span><br><span class="line">WHERE</span><br><span class="line">e.DEPTNO = d.DEPTNO;</span><br></pre></td></tr></table></figure><h5 id="右外连接-右边的表不加限制"><a href="#右外连接-右边的表不加限制" class="headerlink" title="右外连接(右边的表不加限制)"></a>右外连接(右边的表不加限制)</h5><p>–查询出所有的部门,以及部门下的员工信息.[外连接]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">* </span><br><span class="line">FROM</span><br><span class="line">emp e</span><br><span class="line">RIGHT JOIN dept d ON e.DEPTNO = d.DEPTNO;</span><br></pre></td></tr></table></figure></p><h5 id="左外连接-左边的表不加限制"><a href="#左外连接-左边的表不加限制" class="headerlink" title="左外连接(左边的表不加限制)"></a>左外连接(左边的表不加限制)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">* </span><br><span class="line">FROM</span><br><span class="line">emp e</span><br><span class="line">LEFT JOIN dept d ON e.DEPTNO = d.DEPTNO;</span><br></pre></td></tr></table></figure><h5 id="Oracle专用外连接-写在哪边-哪边就是匹配表"><a href="#Oracle专用外连接-写在哪边-哪边就是匹配表" class="headerlink" title="Oracle专用外连接(+写在哪边,哪边就是匹配表)"></a>Oracle专用外连接(+写在哪边,哪边就是匹配表)</h5><hr><p>几点注意:<br>1.放在等号左右都可,需要放在缺少信息的那一边<br>2.改符号仅适用于列,不能用在表达式上<br>3.不能和on和in操作符一起使用<br>4.全外连接不能使用</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">* </span><br><span class="line">FROM</span><br><span class="line">emp e,dept d</span><br><span class="line">where e.DEPTNO(+)=d.DEPTNO;</span><br></pre></td></tr></table></figure><h5 id="全外连接-左表和右表都不受限制"><a href="#全外连接-左表和右表都不受限制" class="headerlink" title="全外连接(左表和右表都不受限制)"></a>全外连接(左表和右表都不受限制)</h5><p>所有记录都显示,两表不足的地方均为null.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">* </span><br><span class="line">FROM</span><br><span class="line">emp e</span><br><span class="line">FULL JOIN dept d ON e.DEPTNO = d.DEPTNO;</span><br></pre></td></tr></table></figure></p><p>查询出员工姓名,员工领导姓名,员工部门,员工领导部门</p><h5 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h5><p>自连接其实就是站在不同角度把一张表看成多张表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">e1.ENAME,</span><br><span class="line">e2.ENAME </span><br><span class="line">FROM</span><br><span class="line">emp e1,</span><br><span class="line">emp e2,</span><br><span class="line">dept d1,</span><br><span class="line">dept d2 </span><br><span class="line">WHERE</span><br><span class="line">e1.DEPTNO = d1.DEPTNO </span><br><span class="line">AND e1.mgr = e2.EMPNO </span><br><span class="line">AND e2.DEPTNO = d2.DEPTNO;</span><br></pre></td></tr></table></figure></p><h5 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h5><h6 id="返回一个值"><a href="#返回一个值" class="headerlink" title="返回一个值"></a>返回一个值</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--查询出工资和SCOTT一样的员工信息</span><br><span class="line">SELECT</span><br><span class="line">* </span><br><span class="line">FROM</span><br><span class="line">emp </span><br><span class="line">WHERE</span><br><span class="line">sal IN (</span><br><span class="line">SELECT</span><br><span class="line">sal </span><br><span class="line">FROM</span><br><span class="line">emp </span><br><span class="line">WHERE</span><br><span class="line">ename = &apos;SCOTT&apos;)</span><br></pre></td></tr></table></figure><h6 id="返回一个集合"><a href="#返回一个集合" class="headerlink" title="返回一个集合"></a>返回一个集合</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--查询出工资和10号部门任意员工一样的员工信息</span><br><span class="line">SELECT</span><br><span class="line">* </span><br><span class="line">FROM</span><br><span class="line">emp </span><br><span class="line">WHERE</span><br><span class="line">sal IN ( SELECT sal FROM emp WHERE DEPTNO = 10 );</span><br></pre></td></tr></table></figure><h6 id="子查询返回一张表"><a href="#子查询返回一张表" class="headerlink" title="子查询返回一张表"></a>子查询返回一张表</h6><p>–查询出每个部门的最低工资和最低工资员工姓名,和该员工所在部门名称</p><ul><li>先查询出每个部门最低工资</li><li>三表联查,得到最终结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">t.DEPTNO,</span><br><span class="line">t.msal,</span><br><span class="line">e.ENAME,</span><br><span class="line">d.DNAME </span><br><span class="line">FROM</span><br><span class="line">( SELECT DEPTNO, min( sal ) msal FROM emp GROUP BY DEPTNO ) t,</span><br><span class="line">emp e,</span><br><span class="line">dept d </span><br><span class="line">WHERE</span><br><span class="line">t.deptno = e.deptno </span><br><span class="line">AND t.msal = e.sal </span><br><span class="line">AND e.deptno = d.deptno;</span><br></pre></td></tr></table></figure><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>rownum行号:当我们做select操作的时候,每查询出一行记录,就会在该行上加一个行号,</p><p>行号从1开始,依次递增,不能跳序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">--排序操作会影响rownum的顺序</span><br><span class="line">select rownum, e.* from emp e order by e.sal desc</span><br><span class="line">--如果涉及到排序，但是还要使用rownum的话，我们可以再次嵌套查询。</span><br><span class="line">SELECT ROWNUM</span><br><span class="line">,</span><br><span class="line">t.* </span><br><span class="line">FROM</span><br><span class="line">( SELECT ROWNUM, e.* FROM EMP e ORDER BY e.sal DESC ) t;</span><br><span class="line"></span><br><span class="line">--emp表工资倒叙排列后，每页五条记录，查询第二页。</span><br><span class="line">--rownum行号不能写上大于一个正数。</span><br><span class="line">SELECT</span><br><span class="line">* </span><br><span class="line">FROM</span><br><span class="line">( SELECT ROWNUM rn, tt.* FROM ( SELECT * FROM emp ORDER BY sal DESC ) tt WHERE ROWNUM &lt; 11 ) </span><br><span class="line">WHERE</span><br><span class="line">rn &gt;5</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;创建表空间&quot;&gt;&lt;a href=&quot;#创建表空间&quot; class=&quot;headerlink&quot; title=&quot;创建表空间&quot;&gt;&lt;/a&gt;创建表空间&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
      <category term="数据库" scheme="https://fzqeven.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Oracle" scheme="https://fzqeven.top/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Oracle学习_02</title>
    <link href="https://fzqeven.top/2018/11/13/Oracle%E5%AD%A6%E4%B9%A0_02/"/>
    <id>https://fzqeven.top/2018/11/13/Oracle学习_02/</id>
    <published>2018-11-13T06:34:04.191Z</published>
    <updated>2018-11-17T07:33:10.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>概念:视图就是提供一个查询的窗口,所有数据来自于原表</p><pre><code>--查询语句创建表create view v_emp as select * from scott.emp;--创建视图[必须要有dba权限]create view v_emp as select ename,job from emp;--查询视图select v_emp ;--修改视图[不推荐使用]update v_emp set job=&apos;CLERK&apos; where ename=&apos;ALLEN&apos;;commit;--创建只读视图create view v_emp1 as select ename ,job from emp with read only;</code></pre><p>–视图的作用:</p><p>–1.视图可以屏蔽掉一些敏感字段</p><p>–2.保证总部和分部数据及时统一</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>–概念:</p><p>–索引就是在表的列上构建一个二叉树,达到大幅度提高查询效率的目的,但是索引会影响增删改的效率</p><p>–类似于数组,以下标的形式去存储和访问表中的数据,索引可以是不连续的</p><blockquote><p>索引索引索引,待更biubiubiubiubiuMark</p></blockquote><h3 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--创建单列索引</span><br><span class="line"></span><br><span class="line">create index idx_ename on emp(ename);</span><br><span class="line"></span><br><span class="line">--单列索引触发规则,条件必须是索引列的原始值.</span><br><span class="line"></span><br><span class="line">--单行函数,模糊查询,都会影响索引的触发</span><br><span class="line"></span><br><span class="line">select * from emp where ename=&apos;SCOTT&apos;</span><br><span class="line"></span><br><span class="line">--复合索引</span><br><span class="line"></span><br><span class="line">--创建复合索引</span><br><span class="line"></span><br><span class="line">create index idx_enamejob on emp(ename,job);</span><br></pre></td></tr></table></figure><h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><p>–复合索引中第一列为优先检索列</p><p>–如果想要触发复合索引,必须包含有优先搜索列中的原始值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where ename =&apos;SCOTT&apos; and job=&apos;XX&apos;;  --触发复合索引</span><br><span class="line"></span><br><span class="line">select * from emp where ename =&apos;SCOTT&apos; or job=&apos;XX&apos;;  --不触发索引</span><br><span class="line"></span><br><span class="line">select * from emp where ename =&apos;SCOTT&apos;  --触发单列索引</span><br></pre></td></tr></table></figure><hr><h2 id="pl-sql编程语言"><a href="#pl-sql编程语言" class="headerlink" title="pl/sql编程语言"></a>pl/sql编程语言</h2><p>–是对sql语言的扩展,似的sql语言具有过程化编程的特性.比一般的过程化编程语言更加灵活高效.</p><p>–主要用来编写存储过程和存储函数等</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>–声明方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">declare</span><br><span class="line">i number(2)  := 10;</span><br><span class="line"></span><br><span class="line">s varchar2(10) := &apos;小明&apos;;</span><br><span class="line"></span><br><span class="line">ena emp.ename%type;  --引用型变量</span><br><span class="line"></span><br><span class="line">emprow emp%rowtype; --记录型变量</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line">dbms_output.put_line(i);</span><br><span class="line"></span><br><span class="line">dbms_output.put_line(s);</span><br><span class="line"></span><br><span class="line">select ename into ena from emp where empno = 7788;</span><br><span class="line"></span><br><span class="line">dbms_output.put_line(ena);</span><br><span class="line"></span><br><span class="line">select  * into emprow from emp where empno = 7788;</span><br><span class="line"></span><br><span class="line">dbms_output.put_line(emprow.ename|| &apos;的工作为:&apos; ||emprow.job);</span><br><span class="line"></span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>–pl/sql中的if判断</p><p>​    –输入小于18的数字,输出未成年</p><p>​    –输入大于18小于40的数字,输出中年人</p><p>​    –输入大于40的数字,输出老年人</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">i NUMBER ( 3 ) := &amp;ii;</span><br><span class="line">BEGIN</span><br><span class="line">IF</span><br><span class="line">i &lt; 18 THEN</span><br><span class="line">dbms_output.put_line ( &apos;未成年&apos; );</span><br><span class="line">elseif i &lt; 40 THEN</span><br><span class="line">dbms_output.put_line ( &apos;中年人&apos; );</span><br><span class="line">ELSE dbms_output.put_line ( &apos;未成年&apos; );</span><br><span class="line">END IF;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>–pl/sql中的loop循环<br>–用三种方式输出1到10是个数字<br>–while循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">i NUMBER ( 2 ) := 1;</span><br><span class="line">BEGIN</span><br><span class="line">while i &lt; 11 loop</span><br><span class="line">dbms_output.put_line ( i );</span><br><span class="line">i := i + 1;</span><br><span class="line">END loop;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>–exit循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DECLARE </span><br><span class="line">i NUMBER ( 2 ) := 1;</span><br><span class="line">BEGIN </span><br><span class="line">loop </span><br><span class="line">exit WHEN i &gt; 10;</span><br><span class="line">dbms_output.put_line ( i );</span><br><span class="line">i := i + 1;</span><br><span class="line">END loop;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>–for循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">declare</span><br><span class="line">begin</span><br><span class="line">for i in 1..10 loop</span><br><span class="line">dbms_output.put_line(i);</span><br><span class="line">end loop;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>–游标:游标(cursor)是系统为用户开设的一个数据缓冲区,存放SQL语句的执行结果,</p></blockquote></blockquote><p>–通俗的说:游标是一段内存区域,用于暂时存放sql语句受影响的数据.将这些数据放到一个内存区域的虚表中,而这个虚表就是游标</p><blockquote><blockquote><p>–作用:</p></blockquote></blockquote><blockquote><blockquote><p>1.数据库是具有回滚功能的，游标在其中有重要的作用。由于对数据库的操作会暂时放在游标中，只要在提交的时候出现异常，我们就可以根据游标就行回滚，在一定意义上有利于数据库的安全。</p></blockquote></blockquote><blockquote><blockquote><p>2.在Oracle中，PL/SQL只能返回单行数据，而游标的出现，可以返回多条数据。</p></blockquote></blockquote><p>–游标一旦关闭，游标占用的资源就被释放，游标变成无效，必须重新打开才能使用。 </p><p>–输出emp表中所有的员工的姓名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DECLARE </span><br><span class="line">cursor c1 IS SELECT * FROM emp;</span><br><span class="line">emprow emp % rowtype;</span><br><span class="line">BEGIN</span><br><span class="line">open c1;</span><br><span class="line">loop</span><br><span class="line">FETCH c1 INTO emprow;</span><br><span class="line">exit </span><br><span class="line">WHEN c1 % notfound;</span><br><span class="line">dbms_output.put_line ( emprow.ename );</span><br><span class="line"></span><br><span class="line">END loop;</span><br><span class="line">close c1;</span><br><span class="line"></span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>–给指定部门员工涨工资</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">declare</span><br><span class="line">--定义游标</span><br><span class="line">cursor c2(eno emp.deptno%type)</span><br><span class="line">is select empno from emp where deptno = eno;</span><br><span class="line">en emp.empno%type;</span><br><span class="line">begin</span><br><span class="line">--打开游标</span><br><span class="line">open c2(10);</span><br><span class="line">loop</span><br><span class="line">--提取游标</span><br><span class="line">fetch c2 into en;</span><br><span class="line">exit when c2%notfound;</span><br><span class="line">update emp set sal=sal+100 where empno=en;</span><br><span class="line">commit;</span><br><span class="line">end loop;</span><br><span class="line">--关闭游标</span><br><span class="line">close c2;</span><br><span class="line">end;</span><br><span class="line">--查询10号部门员工信息</span><br><span class="line">select * from emp where deptno = 10;</span><br></pre></td></tr></table></figure><p>–存储过程</p><p>–存储过程:存储过程就是提前已经编译好的一段pl/sql语言,放置在数据库端</p><p>–可以直接被调用.这一段pl/sql一般都是固定步骤的业务</p><p>–给指定员工涨100块钱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">create procedure p1(eno emp.empno%type)</span><br><span class="line">is</span><br><span class="line">begin </span><br><span class="line">update emp set sal=sal+100 where empno = eno;</span><br><span class="line">commit;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">select * from emp where empno = 7788;</span><br><span class="line">--测试p1</span><br><span class="line">declare</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">p1(7788);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>–通过存储函数实现员工的年薪</p><p>–存储过程和存储函数的参数都不能带长度</p><p>–存储函数的返回值类型不能带长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CREATE </span><br><span class="line">OR REPLACE FUNCTION f_yearsal ( eno emp.empno % TYPE ) return NUMBER IS s NUMBER ( 10 );</span><br><span class="line">BEGIN</span><br><span class="line">SELECT</span><br><span class="line">sal * 12+nvl ( comm, 0 ) INTO s </span><br><span class="line">FROM</span><br><span class="line">emp </span><br><span class="line">WHERE</span><br><span class="line">empno = eno;</span><br><span class="line">return s;</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">--测试 f_yearsal</span><br><span class="line">--存储函数在调用的时候,返回值需要接收</span><br><span class="line">declare </span><br><span class="line">s number(10);</span><br><span class="line">begin </span><br><span class="line">s := f_yearsal(7788);</span><br><span class="line">dbms_output.put_line(s);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>–out类型参数如何使用</p><p>–使用存储过程来算年薪</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CREATE </span><br><span class="line">OR REPLACE PROCEDURE p_yearsal ( eno emp.EMPNO % TYPE, yearsal OUT NUMBER )</span><br><span class="line">IS </span><br><span class="line">s NUMBER ( 10 );</span><br><span class="line">c EMP.COMM % TYPE;</span><br><span class="line">BEGIN</span><br><span class="line">SELECT</span><br><span class="line">sal * 12,</span><br><span class="line">nvl( comm, 0 ) INTO s,</span><br><span class="line">c </span><br><span class="line">FROM</span><br><span class="line">emp </span><br><span class="line">WHERE</span><br><span class="line">empno = eno;</span><br><span class="line">yearsal := s + c;</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">--测试p_yearsal</span><br><span class="line">DECLARE</span><br><span class="line">yearsal NUMBER ( 10 );</span><br><span class="line">BEGIN</span><br><span class="line">p_yearsal ( 7788, yearsal );</span><br><span class="line">dbms_output.put_line ( yearsal );</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><hr><h3 id="in和out类型参数的区别是什么"><a href="#in和out类型参数的区别是什么" class="headerlink" title="in和out类型参数的区别是什么?"></a>in和out类型参数的区别是什么?</h3><p>凡是涉及到into查询语句赋值或者:=赋值操作的参数,都必须使用out来修饰.</p><h3 id="存储过程和存储函数的区别"><a href="#存储过程和存储函数的区别" class="headerlink" title="存储过程和存储函数的区别"></a>存储过程和存储函数的区别</h3><p>语法上:关键字不一样,存储函数比存储过程多了两个return</p><p>本质上:存储函数有返回值,而存储过程没有返回值.</p><p>​        如果存储过程想实现有返回值的业务,这时我们需要使用out类型的参数</p><p>​        即使是存储过程使用了out类型的参数,其本质也不是真的有了返回值</p><p>​        而是在存储过程内部给给out类型参数赋值,在执行完毕后,我们直接拿到输出类型参数的值</p><hr><p>–我们可以使用存储函数有返回值的特性,来定义函数</p><p>–而存储过程不能来定义函数</p><p>–案例需求;查询出员工姓名.员工所在部门名称</p><p>–案例准备工作:把SCOTT用户下的dept表复制到当前用户下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">create table dept as select * from SCOTT.dept;</span><br><span class="line">--使用传统方式来实现案例需求</span><br><span class="line">select e.name ,d.name </span><br><span class="line">from emp e,dept d</span><br><span class="line">where e.deptno = d.deptno;</span><br><span class="line">--使用存储函数来实现提供一个部门编号,输出一个部门名称</span><br><span class="line">CREATE </span><br><span class="line">OR REPLACE FUNCTION fdna ( dno dept.DEPTNO % TYPE ) return dept.DNAME % TYPE </span><br><span class="line">IS </span><br><span class="line">dna dept.DNAME % TYPE;</span><br><span class="line">BEGIN</span><br><span class="line">SELECT</span><br><span class="line">DNAME INTO dna </span><br><span class="line">FROM</span><br><span class="line">dept </span><br><span class="line">WHERE</span><br><span class="line">deptno = dno;</span><br><span class="line">return dna;</span><br><span class="line">END;</span><br><span class="line">--使用fdna存储函数来实现案例需求,查询出员工姓名,员工所在部门名称.</span><br><span class="line">select e.ename, fdna(e.deptno)</span><br><span class="line">from emp e;</span><br></pre></td></tr></table></figure><p>–触发器,就是制定一个规则,在我们做增删改操作的时候,只要满足该规则,自动触发,无需调用,也不能调用</p><p>–触发器分语句级触发器和行级触发器</p><blockquote><p>语句级的触发器可以在某些语句执行前或执行后触发.不包含有for each row的触发器</p><p>行级触发器则是在定义了触发的表的行数据改变时就会被触发一次,包含有for each row</p><blockquote><p>for each row是为了使用:old或者:new对象或者一行记录.</p></blockquote></blockquote><h3 id="语句级触发器"><a href="#语句级触发器" class="headerlink" title="语句级触发器"></a>语句级触发器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--插入一条记录,输出一个新员工入职</span><br><span class="line">create or replace trigger t1</span><br><span class="line">after</span><br><span class="line">insert</span><br><span class="line">on person</span><br><span class="line">declare</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">  dbms_output.put_line(&apos;一个新员工入职&apos;);</span><br><span class="line">end;</span><br><span class="line">--触发t1</span><br><span class="line">insert into person values (1, &apos;小红&apos;);</span><br><span class="line">commit;</span><br><span class="line">[dbms导出:</span><br><span class="line">一个新员工入职]</span><br></pre></td></tr></table></figure><h3 id="行级别触发器"><a href="#行级别触发器" class="headerlink" title="行级别触发器"></a>行级别触发器</h3><p>–不能给员工降薪</p><p>–raise_application_error(-20001~-20999之间, ‘错误提示信息’);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">CREATE or REPLACE TRIGGER t2</span><br><span class="line">before</span><br><span class="line">update</span><br><span class="line">on emp</span><br><span class="line">for each row --行级</span><br><span class="line">DECLARE</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line">if :old.sal&gt;:new.sal then </span><br><span class="line">raise_application_error(-20001,&apos;不能给员工降薪&apos;);</span><br><span class="line">end if;</span><br><span class="line">end;</span><br><span class="line">--触发t2</span><br><span class="line">select * from emp where empno = 7788;</span><br><span class="line">update emp set sal =sal-1 where empno = 7788;</span><br><span class="line">commit;</span><br><span class="line">------------------------------</span><br><span class="line">信息:</span><br><span class="line">update emp set sal =sal-1 where empno = 7788</span><br><span class="line">&gt; ORA-20001: 不能给员工降薪</span><br><span class="line">  ORA-06512: at &quot;SCOTT.T2&quot;, line 5</span><br><span class="line">  ORA-04088: error during execution of trigger &apos;SCOTT.T2&apos;</span><br><span class="line">  </span><br><span class="line">&gt; 时间: 0.002s</span><br><span class="line">------------------------------</span><br></pre></td></tr></table></figure><p>–触发器实现主键自增.[行级触发器]</p><p>–分析:在用户做插入操作之前,拿到即将插入的数据,给该数据的主键列赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">create or replace trigger auid</span><br><span class="line">before</span><br><span class="line">insert</span><br><span class="line">on person</span><br><span class="line">for each row</span><br><span class="line">declare</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">  select s_person.nextval into :new.pid from dual;</span><br><span class="line">end;</span><br><span class="line">--查询person表数据</span><br><span class="line">select * from person;</span><br><span class="line">--使用auid实现主键自增</span><br><span class="line">insert into person (pname) values (&apos;a&apos;);</span><br><span class="line">commit;</span><br><span class="line">insert into person values (1, &apos;b&apos;);</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><hr><h4 id="如何在Navicat中查看触发器"><a href="#如何在Navicat中查看触发器" class="headerlink" title="如何在Navicat中查看触发器?"></a>如何在Navicat中查看触发器?</h4><p>一、选中指定的database，然后再依次选中“其它”、“触发器”</p><p>二、查看已写好的触发器语句 </p><p>​    选中触发器–&gt;DDL</p><p><img src="/images/oracle_02_01.png" alt="触发器"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;视图&quot;&gt;&lt;a href=&quot;#视图&quot; class=&quot;headerlink&quot; title=&quot;视图&quot;&gt;&lt;/a&gt;视图&lt;/h2&gt;&lt;p&gt;概念:视图就是提供一个查询的窗口,所有数据来自于原表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--查询语句创建表

create view v_emp
      
    
    </summary>
    
      <category term="数据库" scheme="https://fzqeven.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Oracle" scheme="https://fzqeven.top/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://fzqeven.top/2018/11/05/hello-world/"/>
    <id>https://fzqeven.top/2018/11/05/hello-world/</id>
    <published>2018-11-05T07:57:03.448Z</published>
    <updated>2018-11-08T02:50:11.233Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="测试分类" scheme="https://fzqeven.top/categories/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="测试标签" scheme="https://fzqeven.top/tags/%E6%B5%8B%E8%AF%95%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
</feed>
